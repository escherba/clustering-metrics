

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>numpy.core.numeric &mdash; Clustering-Metrics 0.0.2 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Clustering-Metrics 0.0.2 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Clustering-Metrics
          

          
          </a>

          
            
            
              <div class="version">
                0.0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../clustering_metrics.html">clustering_metrics package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">Clustering-Metrics</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>numpy.core.numeric</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for numpy.core.numeric</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">numpy.core</span> <span class="k">import</span> <span class="n">multiarray</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">umath</span>
<span class="kn">from</span> <span class="nn">.umath</span> <span class="k">import</span> <span class="p">(</span><span class="n">invert</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">UFUNC_BUFSIZE_DEFAULT</span><span class="p">,</span> <span class="n">ERR_IGNORE</span><span class="p">,</span>
                    <span class="n">ERR_WARN</span><span class="p">,</span> <span class="n">ERR_RAISE</span><span class="p">,</span> <span class="n">ERR_CALL</span><span class="p">,</span> <span class="n">ERR_PRINT</span><span class="p">,</span> <span class="n">ERR_LOG</span><span class="p">,</span>
                    <span class="n">ERR_DEFAULT</span><span class="p">,</span> <span class="n">PINF</span><span class="p">,</span> <span class="n">NAN</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">numerictypes</span>
<span class="kn">from</span> <span class="nn">.numerictypes</span> <span class="k">import</span> <span class="n">longlong</span><span class="p">,</span> <span class="n">intc</span><span class="p">,</span> <span class="n">int_</span><span class="p">,</span> <span class="n">float_</span><span class="p">,</span> <span class="n">complex_</span><span class="p">,</span> <span class="n">bool_</span>
<span class="kn">from</span> <span class="nn">._internal</span> <span class="k">import</span> <span class="n">TooHardError</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pickle</span>
    <span class="n">basestring</span> <span class="o">=</span> <span class="nb">str</span>
    <span class="kn">import</span> <span class="nn">builtins</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cPickle</span> <span class="k">as</span> <span class="nn">pickle</span>
    <span class="kn">import</span> <span class="nn">__builtin__</span> <span class="k">as</span> <span class="nn">builtins</span>

<span class="n">loads</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;newaxis&#39;</span><span class="p">,</span> <span class="s1">&#39;ndarray&#39;</span><span class="p">,</span> <span class="s1">&#39;flatiter&#39;</span><span class="p">,</span> <span class="s1">&#39;nditer&#39;</span><span class="p">,</span> <span class="s1">&#39;nested_iters&#39;</span><span class="p">,</span> <span class="s1">&#39;ufunc&#39;</span><span class="p">,</span>
    <span class="s1">&#39;arange&#39;</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">,</span> <span class="s1">&#39;zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;count_nonzero&#39;</span><span class="p">,</span> <span class="s1">&#39;empty&#39;</span><span class="p">,</span> <span class="s1">&#39;broadcast&#39;</span><span class="p">,</span>
    <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="s1">&#39;fromstring&#39;</span><span class="p">,</span> <span class="s1">&#39;fromfile&#39;</span><span class="p">,</span> <span class="s1">&#39;frombuffer&#39;</span><span class="p">,</span> <span class="s1">&#39;int_asbuffer&#39;</span><span class="p">,</span>
    <span class="s1">&#39;where&#39;</span><span class="p">,</span> <span class="s1">&#39;argwhere&#39;</span><span class="p">,</span> <span class="s1">&#39;copyto&#39;</span><span class="p">,</span> <span class="s1">&#39;concatenate&#39;</span><span class="p">,</span> <span class="s1">&#39;fastCopyAndTranspose&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lexsort&#39;</span><span class="p">,</span> <span class="s1">&#39;set_numeric_ops&#39;</span><span class="p">,</span> <span class="s1">&#39;can_cast&#39;</span><span class="p">,</span> <span class="s1">&#39;promote_types&#39;</span><span class="p">,</span>
    <span class="s1">&#39;min_scalar_type&#39;</span><span class="p">,</span> <span class="s1">&#39;result_type&#39;</span><span class="p">,</span> <span class="s1">&#39;asarray&#39;</span><span class="p">,</span> <span class="s1">&#39;asanyarray&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ascontiguousarray&#39;</span><span class="p">,</span> <span class="s1">&#39;asfortranarray&#39;</span><span class="p">,</span> <span class="s1">&#39;isfortran&#39;</span><span class="p">,</span> <span class="s1">&#39;empty_like&#39;</span><span class="p">,</span>
    <span class="s1">&#39;zeros_like&#39;</span><span class="p">,</span> <span class="s1">&#39;ones_like&#39;</span><span class="p">,</span> <span class="s1">&#39;correlate&#39;</span><span class="p">,</span> <span class="s1">&#39;convolve&#39;</span><span class="p">,</span> <span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="s1">&#39;dot&#39;</span><span class="p">,</span>
    <span class="s1">&#39;einsum&#39;</span><span class="p">,</span> <span class="s1">&#39;outer&#39;</span><span class="p">,</span> <span class="s1">&#39;vdot&#39;</span><span class="p">,</span> <span class="s1">&#39;alterdot&#39;</span><span class="p">,</span> <span class="s1">&#39;restoredot&#39;</span><span class="p">,</span> <span class="s1">&#39;roll&#39;</span><span class="p">,</span>
    <span class="s1">&#39;rollaxis&#39;</span><span class="p">,</span> <span class="s1">&#39;moveaxis&#39;</span><span class="p">,</span> <span class="s1">&#39;cross&#39;</span><span class="p">,</span> <span class="s1">&#39;tensordot&#39;</span><span class="p">,</span> <span class="s1">&#39;array2string&#39;</span><span class="p">,</span>
    <span class="s1">&#39;get_printoptions&#39;</span><span class="p">,</span> <span class="s1">&#39;set_printoptions&#39;</span><span class="p">,</span> <span class="s1">&#39;array_repr&#39;</span><span class="p">,</span> <span class="s1">&#39;array_str&#39;</span><span class="p">,</span>
    <span class="s1">&#39;set_string_function&#39;</span><span class="p">,</span> <span class="s1">&#39;little_endian&#39;</span><span class="p">,</span> <span class="s1">&#39;require&#39;</span><span class="p">,</span> <span class="s1">&#39;fromiter&#39;</span><span class="p">,</span>
    <span class="s1">&#39;array_equal&#39;</span><span class="p">,</span> <span class="s1">&#39;array_equiv&#39;</span><span class="p">,</span> <span class="s1">&#39;indices&#39;</span><span class="p">,</span> <span class="s1">&#39;fromfunction&#39;</span><span class="p">,</span> <span class="s1">&#39;isclose&#39;</span><span class="p">,</span> <span class="s1">&#39;load&#39;</span><span class="p">,</span>
    <span class="s1">&#39;loads&#39;</span><span class="p">,</span> <span class="s1">&#39;isscalar&#39;</span><span class="p">,</span> <span class="s1">&#39;binary_repr&#39;</span><span class="p">,</span> <span class="s1">&#39;base_repr&#39;</span><span class="p">,</span> <span class="s1">&#39;ones&#39;</span><span class="p">,</span> <span class="s1">&#39;identity&#39;</span><span class="p">,</span>
    <span class="s1">&#39;allclose&#39;</span><span class="p">,</span> <span class="s1">&#39;compare_chararrays&#39;</span><span class="p">,</span> <span class="s1">&#39;putmask&#39;</span><span class="p">,</span> <span class="s1">&#39;seterr&#39;</span><span class="p">,</span> <span class="s1">&#39;geterr&#39;</span><span class="p">,</span>
    <span class="s1">&#39;setbufsize&#39;</span><span class="p">,</span> <span class="s1">&#39;getbufsize&#39;</span><span class="p">,</span> <span class="s1">&#39;seterrcall&#39;</span><span class="p">,</span> <span class="s1">&#39;geterrcall&#39;</span><span class="p">,</span> <span class="s1">&#39;errstate&#39;</span><span class="p">,</span>
    <span class="s1">&#39;flatnonzero&#39;</span><span class="p">,</span> <span class="s1">&#39;Inf&#39;</span><span class="p">,</span> <span class="s1">&#39;inf&#39;</span><span class="p">,</span> <span class="s1">&#39;infty&#39;</span><span class="p">,</span> <span class="s1">&#39;Infinity&#39;</span><span class="p">,</span> <span class="s1">&#39;nan&#39;</span><span class="p">,</span> <span class="s1">&#39;NaN&#39;</span><span class="p">,</span> <span class="s1">&#39;False_&#39;</span><span class="p">,</span>
    <span class="s1">&#39;True_&#39;</span><span class="p">,</span> <span class="s1">&#39;bitwise_not&#39;</span><span class="p">,</span> <span class="s1">&#39;CLIP&#39;</span><span class="p">,</span> <span class="s1">&#39;RAISE&#39;</span><span class="p">,</span> <span class="s1">&#39;WRAP&#39;</span><span class="p">,</span> <span class="s1">&#39;MAXDIMS&#39;</span><span class="p">,</span> <span class="s1">&#39;BUFSIZE&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ALLOW_THREADS&#39;</span><span class="p">,</span> <span class="s1">&#39;ComplexWarning&#39;</span><span class="p">,</span> <span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="s1">&#39;full_like&#39;</span><span class="p">,</span> <span class="s1">&#39;matmul&#39;</span><span class="p">,</span>
    <span class="s1">&#39;shares_memory&#39;</span><span class="p">,</span> <span class="s1">&#39;may_share_memory&#39;</span><span class="p">,</span> <span class="s1">&#39;MAY_SHARE_BOUNDS&#39;</span><span class="p">,</span> <span class="s1">&#39;MAY_SHARE_EXACT&#39;</span><span class="p">,</span>
    <span class="s1">&#39;TooHardError&#39;</span><span class="p">,</span>
    <span class="p">]</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
    <span class="n">__all__</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;getbuffer&#39;</span><span class="p">,</span> <span class="s1">&#39;newbuffer&#39;</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">ComplexWarning</span><span class="p">(</span><span class="ne">RuntimeWarning</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The warning raised when casting a complex dtype to a real dtype.</span>

<span class="sd">    As implemented, casting a complex number to a real discards its imaginary</span>
<span class="sd">    part, but this behavior may not be what the user actually wants.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="n">bitwise_not</span> <span class="o">=</span> <span class="n">invert</span>

<span class="n">CLIP</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">CLIP</span>
<span class="n">WRAP</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">WRAP</span>
<span class="n">RAISE</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">RAISE</span>
<span class="n">MAXDIMS</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">MAXDIMS</span>
<span class="n">ALLOW_THREADS</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">ALLOW_THREADS</span>
<span class="n">BUFSIZE</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">BUFSIZE</span>
<span class="n">MAY_SHARE_BOUNDS</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">MAY_SHARE_BOUNDS</span>
<span class="n">MAY_SHARE_EXACT</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">MAY_SHARE_EXACT</span>

<span class="n">ndarray</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">ndarray</span>
<span class="n">flatiter</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">flatiter</span>
<span class="n">nditer</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">nditer</span>
<span class="n">nested_iters</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">nested_iters</span>
<span class="n">broadcast</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">broadcast</span>
<span class="n">dtype</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">dtype</span>
<span class="n">copyto</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">copyto</span>
<span class="n">ufunc</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">sin</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">zeros_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an array of zeros with the same shape and type as a given array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        The shape and data-type of `a` define these same attributes of</span>
<span class="sd">        the returned array.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Overrides the data type of the result.</span>

<span class="sd">        .. versionadded:: 1.6.0</span>
<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;, or &#39;K&#39;}, optional</span>
<span class="sd">        Overrides the memory layout of the result. &#39;C&#39; means C-order,</span>
<span class="sd">        &#39;F&#39; means F-order, &#39;A&#39; means &#39;F&#39; if `a` is Fortran contiguous,</span>
<span class="sd">        &#39;C&#39; otherwise. &#39;K&#39; means match the layout of `a` as closely</span>
<span class="sd">        as possible.</span>

<span class="sd">        .. versionadded:: 1.6.0</span>
<span class="sd">    subok : bool, optional.</span>
<span class="sd">        If True, then the newly created array will use the sub-class</span>
<span class="sd">        type of &#39;a&#39;, otherwise it will be a base-class array. Defaults</span>
<span class="sd">        to True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        Array of zeros with the same shape and type as `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ones_like : Return an array of ones with shape and type of input.</span>
<span class="sd">    empty_like : Return an empty array with shape and type of input.</span>
<span class="sd">    zeros : Return a new array setting values to zero.</span>
<span class="sd">    ones : Return a new array setting values to one.</span>
<span class="sd">    empty : Return a new uninitialized array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(6)</span>
<span class="sd">    &gt;&gt;&gt; x = x.reshape((2, 3))</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [3, 4, 5]])</span>
<span class="sd">    &gt;&gt;&gt; np.zeros_like(x)</span>
<span class="sd">    array([[0, 0, 0],</span>
<span class="sd">           [0, 0, 0]])</span>

<span class="sd">    &gt;&gt;&gt; y = np.arange(3, dtype=np.float)</span>
<span class="sd">    &gt;&gt;&gt; y</span>
<span class="sd">    array([ 0.,  1.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; np.zeros_like(y)</span>
<span class="sd">    array([ 0.,  0.,  0.])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">empty_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="n">subok</span><span class="p">)</span>
    <span class="c1"># needed instead of a 0 to get same result as zeros for for string dtypes</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">res</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">multiarray</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="k">def</span> <span class="nf">ones</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a new array of given shape and type, filled with ones.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : int or sequence of ints</span>
<span class="sd">        Shape of the new array, e.g., ``(2, 3)`` or ``2``.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        The desired data-type for the array, e.g., `numpy.int8`.  Default is</span>
<span class="sd">        `numpy.float64`.</span>
<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;}, optional</span>
<span class="sd">        Whether to store multidimensional data in C- or Fortran-contiguous</span>
<span class="sd">        (row- or column-wise) order in memory.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        Array of ones with the given shape, dtype, and order.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    zeros, ones_like</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.ones(5)</span>
<span class="sd">    array([ 1.,  1.,  1.,  1.,  1.])</span>

<span class="sd">    &gt;&gt;&gt; np.ones((5,), dtype=np.int)</span>
<span class="sd">    array([1, 1, 1, 1, 1])</span>

<span class="sd">    &gt;&gt;&gt; np.ones((2, 1))</span>
<span class="sd">    array([[ 1.],</span>
<span class="sd">           [ 1.]])</span>

<span class="sd">    &gt;&gt;&gt; s = (2,2)</span>
<span class="sd">    &gt;&gt;&gt; np.ones(s)</span>
<span class="sd">    array([[ 1.,  1.],</span>
<span class="sd">           [ 1.,  1.]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
    <span class="n">multiarray</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>

<span class="k">def</span> <span class="nf">ones_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an array of ones with the same shape and type as a given array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        The shape and data-type of `a` define these same attributes of</span>
<span class="sd">        the returned array.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Overrides the data type of the result.</span>

<span class="sd">        .. versionadded:: 1.6.0</span>
<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;, or &#39;K&#39;}, optional</span>
<span class="sd">        Overrides the memory layout of the result. &#39;C&#39; means C-order,</span>
<span class="sd">        &#39;F&#39; means F-order, &#39;A&#39; means &#39;F&#39; if `a` is Fortran contiguous,</span>
<span class="sd">        &#39;C&#39; otherwise. &#39;K&#39; means match the layout of `a` as closely</span>
<span class="sd">        as possible.</span>

<span class="sd">        .. versionadded:: 1.6.0</span>
<span class="sd">    subok : bool, optional.</span>
<span class="sd">        If True, then the newly created array will use the sub-class</span>
<span class="sd">        type of &#39;a&#39;, otherwise it will be a base-class array. Defaults</span>
<span class="sd">        to True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        Array of ones with the same shape and type as `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    zeros_like : Return an array of zeros with shape and type of input.</span>
<span class="sd">    empty_like : Return an empty array with shape and type of input.</span>
<span class="sd">    zeros : Return a new array setting values to zero.</span>
<span class="sd">    ones : Return a new array setting values to one.</span>
<span class="sd">    empty : Return a new uninitialized array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(6)</span>
<span class="sd">    &gt;&gt;&gt; x = x.reshape((2, 3))</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [3, 4, 5]])</span>
<span class="sd">    &gt;&gt;&gt; np.ones_like(x)</span>
<span class="sd">    array([[1, 1, 1],</span>
<span class="sd">           [1, 1, 1]])</span>

<span class="sd">    &gt;&gt;&gt; y = np.arange(3, dtype=np.float)</span>
<span class="sd">    &gt;&gt;&gt; y</span>
<span class="sd">    array([ 0.,  1.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; np.ones_like(y)</span>
<span class="sd">    array([ 1.,  1.,  1.])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">empty_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="n">subok</span><span class="p">)</span>
    <span class="n">multiarray</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="k">def</span> <span class="nf">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a new array of given shape and type, filled with `fill_value`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : int or sequence of ints</span>
<span class="sd">        Shape of the new array, e.g., ``(2, 3)`` or ``2``.</span>
<span class="sd">    fill_value : scalar</span>
<span class="sd">        Fill value.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        The desired data-type for the array, e.g., `np.int8`.  Default</span>
<span class="sd">        is `float`, but will change to `np.array(fill_value).dtype` in a</span>
<span class="sd">        future release.</span>
<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;}, optional</span>
<span class="sd">        Whether to store multidimensional data in C- or Fortran-contiguous</span>
<span class="sd">        (row- or column-wise) order in memory.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        Array of `fill_value` with the given shape, dtype, and order.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    zeros_like : Return an array of zeros with shape and type of input.</span>
<span class="sd">    ones_like : Return an array of ones with shape and type of input.</span>
<span class="sd">    empty_like : Return an empty array with shape and type of input.</span>
<span class="sd">    full_like : Fill an array with shape and type of input.</span>
<span class="sd">    zeros : Return a new array setting values to zero.</span>
<span class="sd">    ones : Return a new array setting values to one.</span>
<span class="sd">    empty : Return a new uninitialized array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.full((2, 2), np.inf)</span>
<span class="sd">    array([[ inf,  inf],</span>
<span class="sd">           [ inf,  inf]])</span>
<span class="sd">    &gt;&gt;&gt; np.full((2, 2), 10, dtype=np.int)</span>
<span class="sd">    array([[10, 10],</span>
<span class="sd">           [10, 10]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">array</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;in the future, full(</span><span class="si">{0}</span><span class="s2">, </span><span class="si">{1!r}</span><span class="s2">) will return an array of </span><span class="si">{2!r}</span><span class="s2">&quot;</span><span class="o">.</span>
            <span class="nb">format</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">array</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="ne">FutureWarning</span><span class="p">)</span>
    <span class="n">multiarray</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>

<span class="k">def</span> <span class="nf">full_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a full array with the same shape and type as a given array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        The shape and data-type of `a` define these same attributes of</span>
<span class="sd">        the returned array.</span>
<span class="sd">    fill_value : scalar</span>
<span class="sd">        Fill value.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Overrides the data type of the result.</span>
<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;, or &#39;K&#39;}, optional</span>
<span class="sd">        Overrides the memory layout of the result. &#39;C&#39; means C-order,</span>
<span class="sd">        &#39;F&#39; means F-order, &#39;A&#39; means &#39;F&#39; if `a` is Fortran contiguous,</span>
<span class="sd">        &#39;C&#39; otherwise. &#39;K&#39; means match the layout of `a` as closely</span>
<span class="sd">        as possible.</span>
<span class="sd">    subok : bool, optional.</span>
<span class="sd">        If True, then the newly created array will use the sub-class</span>
<span class="sd">        type of &#39;a&#39;, otherwise it will be a base-class array. Defaults</span>
<span class="sd">        to True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        Array of `fill_value` with the same shape and type as `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    zeros_like : Return an array of zeros with shape and type of input.</span>
<span class="sd">    ones_like : Return an array of ones with shape and type of input.</span>
<span class="sd">    empty_like : Return an empty array with shape and type of input.</span>
<span class="sd">    zeros : Return a new array setting values to zero.</span>
<span class="sd">    ones : Return a new array setting values to one.</span>
<span class="sd">    empty : Return a new uninitialized array.</span>
<span class="sd">    full : Fill a new array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(6, dtype=np.int)</span>
<span class="sd">    &gt;&gt;&gt; np.full_like(x, 1)</span>
<span class="sd">    array([1, 1, 1, 1, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; np.full_like(x, 0.1)</span>
<span class="sd">    array([0, 0, 0, 0, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; np.full_like(x, 0.1, dtype=np.double)</span>
<span class="sd">    array([ 0.1,  0.1,  0.1,  0.1,  0.1,  0.1])</span>
<span class="sd">    &gt;&gt;&gt; np.full_like(x, np.nan, dtype=np.double)</span>
<span class="sd">    array([ nan,  nan,  nan,  nan,  nan,  nan])</span>

<span class="sd">    &gt;&gt;&gt; y = np.arange(6, dtype=np.double)</span>
<span class="sd">    &gt;&gt;&gt; np.full_like(y, 0.1)</span>
<span class="sd">    array([ 0.1,  0.1,  0.1,  0.1,  0.1,  0.1])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">empty_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="n">subok</span><span class="p">)</span>
    <span class="n">multiarray</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">extend_all</span><span class="p">(</span><span class="n">module</span><span class="p">):</span>
    <span class="n">adict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">__all__</span><span class="p">:</span>
        <span class="n">adict</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">mall</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s1">&#39;__all__&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">mall</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">mall</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adict</span><span class="p">:</span>
            <span class="n">__all__</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="n">newaxis</span> <span class="o">=</span> <span class="kc">None</span>


<span class="n">arange</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">arange</span>
<span class="n">array</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">array</span>
<span class="n">zeros</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">zeros</span>
<span class="n">count_nonzero</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">count_nonzero</span>
<span class="n">empty</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">empty</span>
<span class="n">empty_like</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">empty_like</span>
<span class="n">fromstring</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">fromstring</span>
<span class="n">fromiter</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">fromiter</span>
<span class="n">fromfile</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">fromfile</span>
<span class="n">frombuffer</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">frombuffer</span>
<span class="n">shares_memory</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">shares_memory</span>
<span class="n">may_share_memory</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">may_share_memory</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
    <span class="n">newbuffer</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">newbuffer</span>
    <span class="n">getbuffer</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">getbuffer</span>
<span class="n">int_asbuffer</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">int_asbuffer</span>
<span class="n">where</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">where</span>
<span class="n">concatenate</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">concatenate</span>
<span class="n">fastCopyAndTranspose</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">_fastCopyAndTranspose</span>
<span class="n">set_numeric_ops</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">set_numeric_ops</span>
<span class="n">can_cast</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">can_cast</span>
<span class="n">promote_types</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">promote_types</span>
<span class="n">min_scalar_type</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">min_scalar_type</span>
<span class="n">result_type</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">result_type</span>
<span class="n">lexsort</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">lexsort</span>
<span class="n">compare_chararrays</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">compare_chararrays</span>
<span class="n">putmask</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">putmask</span>
<span class="n">einsum</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">einsum</span>
<span class="n">dot</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">dot</span>
<span class="n">inner</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">inner</span>
<span class="n">vdot</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">vdot</span>
<span class="n">matmul</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">matmul</span>


<span class="k">def</span> <span class="nf">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert the input to an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data, in any form that can be converted to an array.  This</span>
<span class="sd">        includes lists, lists of tuples, tuples, tuples of tuples, tuples</span>
<span class="sd">        of lists and ndarrays.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        By default, the data-type is inferred from the input data.</span>
<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;}, optional</span>
<span class="sd">        Whether to use row-major (C-style) or</span>
<span class="sd">        column-major (Fortran-style) memory representation.</span>
<span class="sd">        Defaults to &#39;C&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        Array interpretation of `a`.  No copy is performed if the input</span>
<span class="sd">        is already an ndarray.  If `a` is a subclass of ndarray, a base</span>
<span class="sd">        class ndarray is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    asanyarray : Similar function which passes through subclasses.</span>
<span class="sd">    ascontiguousarray : Convert input to a contiguous array.</span>
<span class="sd">    asfarray : Convert input to a floating point ndarray.</span>
<span class="sd">    asfortranarray : Convert input to an ndarray with column-major</span>
<span class="sd">                     memory order.</span>
<span class="sd">    asarray_chkfinite : Similar function which checks input for NaNs and Infs.</span>
<span class="sd">    fromiter : Create an array from an iterator.</span>
<span class="sd">    fromfunction : Construct an array by executing a function on grid</span>
<span class="sd">                   positions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Convert a list into an array:</span>

<span class="sd">    &gt;&gt;&gt; a = [1, 2]</span>
<span class="sd">    &gt;&gt;&gt; np.asarray(a)</span>
<span class="sd">    array([1, 2])</span>

<span class="sd">    Existing arrays are not copied:</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([1, 2])</span>
<span class="sd">    &gt;&gt;&gt; np.asarray(a) is a</span>
<span class="sd">    True</span>

<span class="sd">    If `dtype` is set, array is copied only if dtype does not match:</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([1, 2], dtype=np.float32)</span>
<span class="sd">    &gt;&gt;&gt; np.asarray(a, dtype=np.float32) is a</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.asarray(a, dtype=np.float64) is a</span>
<span class="sd">    False</span>

<span class="sd">    Contrary to `asanyarray`, ndarray subclasses are not passed through:</span>

<span class="sd">    &gt;&gt;&gt; issubclass(np.matrix, np.ndarray)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; a = np.matrix([[1, 2]])</span>
<span class="sd">    &gt;&gt;&gt; np.asarray(a) is a</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; np.asanyarray(a) is a</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert the input to an ndarray, but pass ndarray subclasses through.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data, in any form that can be converted to an array.  This</span>
<span class="sd">        includes scalars, lists, lists of tuples, tuples, tuples of tuples,</span>
<span class="sd">        tuples of lists, and ndarrays.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        By default, the data-type is inferred from the input data.</span>
<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;}, optional</span>
<span class="sd">        Whether to use row-major (C-style) or column-major</span>
<span class="sd">        (Fortran-style) memory representation.  Defaults to &#39;C&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray or an ndarray subclass</span>
<span class="sd">        Array interpretation of `a`.  If `a` is an ndarray or a subclass</span>
<span class="sd">        of ndarray, it is returned as-is and no copy is performed.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    asarray : Similar function which always returns ndarrays.</span>
<span class="sd">    ascontiguousarray : Convert input to a contiguous array.</span>
<span class="sd">    asfarray : Convert input to a floating point ndarray.</span>
<span class="sd">    asfortranarray : Convert input to an ndarray with column-major</span>
<span class="sd">                     memory order.</span>
<span class="sd">    asarray_chkfinite : Similar function which checks input for NaNs and</span>
<span class="sd">                        Infs.</span>
<span class="sd">    fromiter : Create an array from an iterator.</span>
<span class="sd">    fromfunction : Construct an array by executing a function on grid</span>
<span class="sd">                   positions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Convert a list into an array:</span>

<span class="sd">    &gt;&gt;&gt; a = [1, 2]</span>
<span class="sd">    &gt;&gt;&gt; np.asanyarray(a)</span>
<span class="sd">    array([1, 2])</span>

<span class="sd">    Instances of `ndarray` subclasses are passed through as-is:</span>

<span class="sd">    &gt;&gt;&gt; a = np.matrix([1, 2])</span>
<span class="sd">    &gt;&gt;&gt; np.asanyarray(a) is a</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">ascontiguousarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a contiguous array in memory (C order).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    dtype : str or dtype object, optional</span>
<span class="sd">        Data-type of returned array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        Contiguous array of same shape and content as `a`, with type `dtype`</span>
<span class="sd">        if specified.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    asfortranarray : Convert input to an ndarray with column-major</span>
<span class="sd">                     memory order.</span>
<span class="sd">    require : Return an ndarray that satisfies requirements.</span>
<span class="sd">    ndarray.flags : Information about the memory layout of the array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(6).reshape(2,3)</span>
<span class="sd">    &gt;&gt;&gt; np.ascontiguousarray(x, dtype=np.float32)</span>
<span class="sd">    array([[ 0.,  1.,  2.],</span>
<span class="sd">           [ 3.,  4.,  5.]], dtype=float32)</span>
<span class="sd">    &gt;&gt;&gt; x.flags[&#39;C_CONTIGUOUS&#39;]</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">asfortranarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an array laid out in Fortran order in memory.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    dtype : str or dtype object, optional</span>
<span class="sd">        By default, the data-type is inferred from the input data.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        The input `a` in Fortran, or column-major, order.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ascontiguousarray : Convert input to a contiguous (C order) array.</span>
<span class="sd">    asanyarray : Convert input to an ndarray with either row or</span>
<span class="sd">        column-major memory order.</span>
<span class="sd">    require : Return an ndarray that satisfies requirements.</span>
<span class="sd">    ndarray.flags : Information about the memory layout of the array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(6).reshape(2,3)</span>
<span class="sd">    &gt;&gt;&gt; y = np.asfortranarray(x)</span>
<span class="sd">    &gt;&gt;&gt; x.flags[&#39;F_CONTIGUOUS&#39;]</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; y.flags[&#39;F_CONTIGUOUS&#39;]</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">require</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an ndarray of the provided type that satisfies requirements.</span>

<span class="sd">    This function is useful to be sure that an array with the correct flags</span>
<span class="sd">    is returned for passing to compiled code (perhaps through ctypes).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">       The object to be converted to a type-and-requirement-satisfying array.</span>
<span class="sd">    dtype : data-type</span>
<span class="sd">       The required data-type. If None preserve the current dtype. If your</span>
<span class="sd">       application requires the data to be in native byteorder, include</span>
<span class="sd">       a byteorder specification as a part of the dtype specification.</span>
<span class="sd">    requirements : str or list of str</span>
<span class="sd">       The requirements list can be any of the following</span>

<span class="sd">       * &#39;F_CONTIGUOUS&#39; (&#39;F&#39;) - ensure a Fortran-contiguous array</span>
<span class="sd">       * &#39;C_CONTIGUOUS&#39; (&#39;C&#39;) - ensure a C-contiguous array</span>
<span class="sd">       * &#39;ALIGNED&#39; (&#39;A&#39;)      - ensure a data-type aligned array</span>
<span class="sd">       * &#39;WRITEABLE&#39; (&#39;W&#39;)    - ensure a writable array</span>
<span class="sd">       * &#39;OWNDATA&#39; (&#39;O&#39;)      - ensure an array that owns its own data</span>
<span class="sd">       * &#39;ENSUREARRAY&#39;, (&#39;E&#39;) - ensure a base array, instead of a subclass</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    asarray : Convert input to an ndarray.</span>
<span class="sd">    asanyarray : Convert to an ndarray, but pass through ndarray subclasses.</span>
<span class="sd">    ascontiguousarray : Convert input to a contiguous array.</span>
<span class="sd">    asfortranarray : Convert input to an ndarray with column-major</span>
<span class="sd">                     memory order.</span>
<span class="sd">    ndarray.flags : Information about the memory layout of the array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The returned array will be guaranteed to have the listed requirements</span>
<span class="sd">    by making a copy if needed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(6).reshape(2,3)</span>
<span class="sd">    &gt;&gt;&gt; x.flags</span>
<span class="sd">      C_CONTIGUOUS : True</span>
<span class="sd">      F_CONTIGUOUS : False</span>
<span class="sd">      OWNDATA : False</span>
<span class="sd">      WRITEABLE : True</span>
<span class="sd">      ALIGNED : True</span>
<span class="sd">      UPDATEIFCOPY : False</span>

<span class="sd">    &gt;&gt;&gt; y = np.require(x, dtype=np.float32, requirements=[&#39;A&#39;, &#39;O&#39;, &#39;W&#39;, &#39;F&#39;])</span>
<span class="sd">    &gt;&gt;&gt; y.flags</span>
<span class="sd">      C_CONTIGUOUS : False</span>
<span class="sd">      F_CONTIGUOUS : True</span>
<span class="sd">      OWNDATA : True</span>
<span class="sd">      WRITEABLE : True</span>
<span class="sd">      ALIGNED : True</span>
<span class="sd">      UPDATEIFCOPY : False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">possible_flags</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C_CONTIGUOUS&#39;</span><span class="p">:</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;CONTIGUOUS&#39;</span><span class="p">:</span><span class="s1">&#39;C&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;F&#39;</span><span class="p">:</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;F_CONTIGUOUS&#39;</span><span class="p">:</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;FORTRAN&#39;</span><span class="p">:</span><span class="s1">&#39;F&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;A&#39;</span><span class="p">:</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;ALIGNED&#39;</span><span class="p">:</span><span class="s1">&#39;A&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;W&#39;</span><span class="p">:</span><span class="s1">&#39;W&#39;</span><span class="p">,</span> <span class="s1">&#39;WRITEABLE&#39;</span><span class="p">:</span><span class="s1">&#39;W&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;O&#39;</span><span class="p">:</span><span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="s1">&#39;OWNDATA&#39;</span><span class="p">:</span><span class="s1">&#39;O&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;E&#39;</span><span class="p">:</span><span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;ENSUREARRAY&#39;</span><span class="p">:</span><span class="s1">&#39;E&#39;</span><span class="p">}</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">requirements</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">requirements</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">possible_flags</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">requirements</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;E&#39;</span> <span class="ow">in</span> <span class="n">requirements</span><span class="p">:</span>
        <span class="n">requirements</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">)</span>
        <span class="n">subok</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">subok</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">order</span> <span class="o">=</span> <span class="s1">&#39;A&#39;</span>
    <span class="k">if</span> <span class="n">requirements</span> <span class="o">&gt;=</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot specify both &quot;C&quot; and &quot;F&quot; order&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="s1">&#39;F&#39;</span> <span class="ow">in</span> <span class="n">requirements</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span>
        <span class="n">requirements</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="s1">&#39;C&#39;</span> <span class="ow">in</span> <span class="n">requirements</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="s1">&#39;C&#39;</span>
        <span class="n">requirements</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>

    <span class="n">arr</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="n">subok</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">requirements</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">arr</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="n">prop</span><span class="p">]:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">arr</span>

<span class="k">def</span> <span class="nf">isfortran</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if the array is Fortran contiguous but *not* C contiguous.</span>

<span class="sd">    This function is obsolete and, because of changes due to relaxed stride</span>
<span class="sd">    checking, its return value for the same array may differ for versions</span>
<span class="sd">    of Numpy &gt;= 1.10 and previous versions. If you only want to check if an</span>
<span class="sd">    array is Fortran contiguous use ``a.flags.f_contiguous`` instead.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        Input array.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    np.array allows to specify whether the array is written in C-contiguous</span>
<span class="sd">    order (last index varies the fastest), or FORTRAN-contiguous order in</span>
<span class="sd">    memory (first index varies the fastest).</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]], order=&#39;C&#39;)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[1, 2, 3],</span>
<span class="sd">           [4, 5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; np.isfortran(a)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; b = np.array([[1, 2, 3], [4, 5, 6]], order=&#39;FORTRAN&#39;)</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    array([[1, 2, 3],</span>
<span class="sd">           [4, 5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; np.isfortran(b)</span>
<span class="sd">    True</span>


<span class="sd">    The transpose of a C-ordered array is a FORTRAN-ordered array.</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]], order=&#39;C&#39;)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[1, 2, 3],</span>
<span class="sd">           [4, 5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; np.isfortran(a)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; b = a.T</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    array([[1, 4],</span>
<span class="sd">           [2, 5],</span>
<span class="sd">           [3, 6]])</span>
<span class="sd">    &gt;&gt;&gt; np.isfortran(b)</span>
<span class="sd">    True</span>

<span class="sd">    C-ordered arrays evaluate as False even if they are also FORTRAN-ordered.</span>

<span class="sd">    &gt;&gt;&gt; np.isfortran(np.array([1, 2], order=&#39;FORTRAN&#39;))</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">fnc</span>

<span class="k">def</span> <span class="nf">argwhere</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the indices of array elements that are non-zero, grouped by element.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    index_array : ndarray</span>
<span class="sd">        Indices of elements that are non-zero. Indices are grouped by element.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    where, nonzero</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ``np.argwhere(a)`` is the same as ``np.transpose(np.nonzero(a))``.</span>

<span class="sd">    The output of ``argwhere`` is not suitable for indexing arrays.</span>
<span class="sd">    For this purpose use ``where(a)`` instead.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(6).reshape(2,3)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [3, 4, 5]])</span>
<span class="sd">    &gt;&gt;&gt; np.argwhere(x&gt;1)</span>
<span class="sd">    array([[0, 2],</span>
<span class="sd">           [1, 0],</span>
<span class="sd">           [1, 1],</span>
<span class="sd">           [1, 2]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="n">nonzero</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">flatnonzero</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return indices that are non-zero in the flattened version of a.</span>

<span class="sd">    This is equivalent to a.ravel().nonzero()[0].</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    res : ndarray</span>
<span class="sd">        Output array, containing the indices of the elements of `a.ravel()`</span>
<span class="sd">        that are non-zero.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    nonzero : Return the indices of the non-zero elements of the input array.</span>
<span class="sd">    ravel : Return a 1-D array containing the elements of the input array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(-2, 3)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([-2, -1,  0,  1,  2])</span>
<span class="sd">    &gt;&gt;&gt; np.flatnonzero(x)</span>
<span class="sd">    array([0, 1, 3, 4])</span>

<span class="sd">    Use the indices of the non-zero elements as an index array to extract</span>
<span class="sd">    these elements:</span>

<span class="sd">    &gt;&gt;&gt; x.ravel()[np.flatnonzero(x)]</span>
<span class="sd">    array([-2, -1,  1,  2])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">_mode_from_name_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;v&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                        <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>

<span class="k">def</span> <span class="nf">_mode_from_name</span><span class="p">(</span><span class="n">mode</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_mode_from_name_dict</span><span class="p">[</span><span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">mode</span>

<span class="k">def</span> <span class="nf">correlate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cross-correlation of two 1-dimensional sequences.</span>

<span class="sd">    This function computes the correlation as generally defined in signal</span>
<span class="sd">    processing texts::</span>

<span class="sd">        c_{av}[k] = sum_n a[n+k] * conj(v[n])</span>

<span class="sd">    with a and v sequences being zero-padded where necessary and conj being</span>
<span class="sd">    the conjugate.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, v : array_like</span>
<span class="sd">        Input sequences.</span>
<span class="sd">    mode : {&#39;valid&#39;, &#39;same&#39;, &#39;full&#39;}, optional</span>
<span class="sd">        Refer to the `convolve` docstring.  Note that the default</span>
<span class="sd">        is &#39;valid&#39;, unlike `convolve`, which uses &#39;full&#39;.</span>
<span class="sd">    old_behavior : bool</span>
<span class="sd">        `old_behavior` was removed in NumPy 1.10. If you need the old</span>
<span class="sd">        behavior, use `multiarray.correlate`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        Discrete cross-correlation of `a` and `v`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    convolve : Discrete, linear convolution of two one-dimensional sequences.</span>
<span class="sd">    multiarray.correlate : Old, no conjugate, version of correlate.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The definition of correlation above is not unique and sometimes correlation</span>
<span class="sd">    may be defined differently. Another common definition is::</span>

<span class="sd">        c&#39;_{av}[k] = sum_n a[n] conj(v[n+k])</span>

<span class="sd">    which is related to ``c_{av}[k]`` by ``c&#39;_{av}[k] = c_{av}[-k]``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.correlate([1, 2, 3], [0, 1, 0.5])</span>
<span class="sd">    array([ 3.5])</span>
<span class="sd">    &gt;&gt;&gt; np.correlate([1, 2, 3], [0, 1, 0.5], &quot;same&quot;)</span>
<span class="sd">    array([ 2. ,  3.5,  3. ])</span>
<span class="sd">    &gt;&gt;&gt; np.correlate([1, 2, 3], [0, 1, 0.5], &quot;full&quot;)</span>
<span class="sd">    array([ 0.5,  2. ,  3.5,  3. ,  0. ])</span>

<span class="sd">    Using complex sequences:</span>

<span class="sd">    &gt;&gt;&gt; np.correlate([1+1j, 2, 3-1j], [0, 1, 0.5j], &#39;full&#39;)</span>
<span class="sd">    array([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])</span>

<span class="sd">    Note that you get the time reversed, complex conjugated result</span>
<span class="sd">    when the two input sequences change places, i.e.,</span>
<span class="sd">    ``c_{va}[k] = c^{*}_{av}[-k]``:</span>

<span class="sd">    &gt;&gt;&gt; np.correlate([0, 1, 0.5j], [1+1j, 2, 3-1j], &#39;full&#39;)</span>
<span class="sd">    array([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">_mode_from_name</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">correlate2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">convolve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the discrete, linear convolution of two one-dimensional sequences.</span>

<span class="sd">    The convolution operator is often seen in signal processing, where it</span>
<span class="sd">    models the effect of a linear time-invariant system on a signal [1]_.  In</span>
<span class="sd">    probability theory, the sum of two independent random variables is</span>
<span class="sd">    distributed according to the convolution of their individual</span>
<span class="sd">    distributions.</span>

<span class="sd">    If `v` is longer than `a`, the arrays are swapped before computation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (N,) array_like</span>
<span class="sd">        First one-dimensional input array.</span>
<span class="sd">    v : (M,) array_like</span>
<span class="sd">        Second one-dimensional input array.</span>
<span class="sd">    mode : {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span>
<span class="sd">        &#39;full&#39;:</span>
<span class="sd">          By default, mode is &#39;full&#39;.  This returns the convolution</span>
<span class="sd">          at each point of overlap, with an output shape of (N+M-1,). At</span>
<span class="sd">          the end-points of the convolution, the signals do not overlap</span>
<span class="sd">          completely, and boundary effects may be seen.</span>

<span class="sd">        &#39;same&#39;:</span>
<span class="sd">          Mode &#39;same&#39; returns output of length ``max(M, N)``.  Boundary</span>
<span class="sd">          effects are still visible.</span>

<span class="sd">        &#39;valid&#39;:</span>
<span class="sd">          Mode &#39;valid&#39; returns output of length</span>
<span class="sd">          ``max(M, N) - min(M, N) + 1``.  The convolution product is only given</span>
<span class="sd">          for points where the signals overlap completely.  Values outside</span>
<span class="sd">          the signal boundary have no effect.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        Discrete, linear convolution of `a` and `v`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.signal.fftconvolve : Convolve two arrays using the Fast Fourier</span>
<span class="sd">                               Transform.</span>
<span class="sd">    scipy.linalg.toeplitz : Used to construct the convolution operator.</span>
<span class="sd">    polymul : Polynomial multiplication. Same output as convolve, but also</span>
<span class="sd">              accepts poly1d objects as input.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The discrete convolution operation is defined as</span>

<span class="sd">    .. math:: (a * v)[n] = \\sum_{m = -\\infty}^{\\infty} a[m] v[n - m]</span>

<span class="sd">    It can be shown that a convolution :math:`x(t) * y(t)` in time/space</span>
<span class="sd">    is equivalent to the multiplication :math:`X(f) Y(f)` in the Fourier</span>
<span class="sd">    domain, after appropriate padding (padding is necessary to prevent</span>
<span class="sd">    circular convolution).  Since multiplication is more efficient (faster)</span>
<span class="sd">    than convolution, the function `scipy.signal.fftconvolve` exploits the</span>
<span class="sd">    FFT to calculate the convolution of large data-sets.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia, &quot;Convolution&quot;, http://en.wikipedia.org/wiki/Convolution.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Note how the convolution operator flips the second array</span>
<span class="sd">    before &quot;sliding&quot; the two across one another:</span>

<span class="sd">    &gt;&gt;&gt; np.convolve([1, 2, 3], [0, 1, 0.5])</span>
<span class="sd">    array([ 0. ,  1. ,  2.5,  4. ,  1.5])</span>

<span class="sd">    Only return the middle values of the convolution.</span>
<span class="sd">    Contains boundary effects, where zeros are taken</span>
<span class="sd">    into account:</span>

<span class="sd">    &gt;&gt;&gt; np.convolve([1,2,3],[0,1,0.5], &#39;same&#39;)</span>
<span class="sd">    array([ 1. ,  2.5,  4. ])</span>

<span class="sd">    The two arrays are of the same length, so there</span>
<span class="sd">    is only one position where they completely overlap:</span>

<span class="sd">    &gt;&gt;&gt; np.convolve([1,2,3],[0,1,0.5], &#39;valid&#39;)</span>
<span class="sd">    array([ 2.5])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">,</span> <span class="n">a</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;a cannot be empty&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;v cannot be empty&#39;</span><span class="p">)</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">_mode_from_name</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">mode</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">outer</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the outer product of two vectors.</span>

<span class="sd">    Given two vectors, ``a = [a0, a1, ..., aM]`` and</span>
<span class="sd">    ``b = [b0, b1, ..., bN]``,</span>
<span class="sd">    the outer product [1]_ is::</span>

<span class="sd">      [[a0*b0  a0*b1 ... a0*bN ]</span>
<span class="sd">       [a1*b0    .</span>
<span class="sd">       [ ...          .</span>
<span class="sd">       [aM*b0            aM*bN ]]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (M,) array_like</span>
<span class="sd">        First input vector.  Input is flattened if</span>
<span class="sd">        not already 1-dimensional.</span>
<span class="sd">    b : (N,) array_like</span>
<span class="sd">        Second input vector.  Input is flattened if</span>
<span class="sd">        not already 1-dimensional.</span>
<span class="sd">    out : (M, N) ndarray, optional</span>
<span class="sd">        A location where the result is stored</span>

<span class="sd">        .. versionadded:: 1.9.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : (M, N) ndarray</span>
<span class="sd">        ``out[i, j] = a[i] * b[j]``</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    inner, einsum</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] : G. H. Golub and C. F. van Loan, *Matrix Computations*, 3rd</span>
<span class="sd">             ed., Baltimore, MD, Johns Hopkins University Press, 1996,</span>
<span class="sd">             pg. 8.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Make a (*very* coarse) grid for computing a Mandelbrot set:</span>

<span class="sd">    &gt;&gt;&gt; rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))</span>
<span class="sd">    &gt;&gt;&gt; rl</span>
<span class="sd">    array([[-2., -1.,  0.,  1.,  2.],</span>
<span class="sd">           [-2., -1.,  0.,  1.,  2.],</span>
<span class="sd">           [-2., -1.,  0.,  1.,  2.],</span>
<span class="sd">           [-2., -1.,  0.,  1.,  2.],</span>
<span class="sd">           [-2., -1.,  0.,  1.,  2.]])</span>
<span class="sd">    &gt;&gt;&gt; im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))</span>
<span class="sd">    &gt;&gt;&gt; im</span>
<span class="sd">    array([[ 0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j],</span>
<span class="sd">           [ 0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j],</span>
<span class="sd">           [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],</span>
<span class="sd">           [ 0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j],</span>
<span class="sd">           [ 0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j]])</span>
<span class="sd">    &gt;&gt;&gt; grid = rl + im</span>
<span class="sd">    &gt;&gt;&gt; grid</span>
<span class="sd">    array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],</span>
<span class="sd">           [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],</span>
<span class="sd">           [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],</span>
<span class="sd">           [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],</span>
<span class="sd">           [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])</span>

<span class="sd">    An example using a &quot;vector&quot; of letters:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=object)</span>
<span class="sd">    &gt;&gt;&gt; np.outer(x, [1, 2, 3])</span>
<span class="sd">    array([[a, aa, aaa],</span>
<span class="sd">           [b, bb, bbb],</span>
<span class="sd">           [c, cc, ccc]], dtype=object)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">multiply</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[:,</span> <span class="n">newaxis</span><span class="p">],</span> <span class="n">b</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">newaxis</span><span class="p">,:],</span> <span class="n">out</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">alterdot</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Change `dot`, `vdot`, and `inner` to use accelerated BLAS functions.</span>

<span class="sd">    Typically, as a user of Numpy, you do not explicitly call this</span>
<span class="sd">    function. If Numpy is built with an accelerated BLAS, this function is</span>
<span class="sd">    automatically called when Numpy is imported.</span>

<span class="sd">    When Numpy is built with an accelerated BLAS like ATLAS, these</span>
<span class="sd">    functions are replaced to make use of the faster implementations.  The</span>
<span class="sd">    faster implementations only affect float32, float64, complex64, and</span>
<span class="sd">    complex128 arrays. Furthermore, the BLAS API only includes</span>
<span class="sd">    matrix-matrix, matrix-vector, and vector-vector products. Products of</span>
<span class="sd">    arrays with larger dimensionalities use the built in functions and are</span>
<span class="sd">    not accelerated.</span>

<span class="sd">    .. note:: Deprecated in Numpy 1.10</span>
<span class="sd">              The cblas functions have been integrated into the multarray</span>
<span class="sd">              module and alterdot now longer does anything. It will be</span>
<span class="sd">              removed in Numpy 1.11.0.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    restoredot : `restoredot` undoes the effects of `alterdot`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 2014-08-13, 1.10</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;alterdot no longer does anything.&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">restoredot</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Restore `dot`, `vdot`, and `innerproduct` to the default non-BLAS</span>
<span class="sd">    implementations.</span>

<span class="sd">    Typically, the user will only need to call this when troubleshooting</span>
<span class="sd">    and installation problem, reproducing the conditions of a build without</span>
<span class="sd">    an accelerated BLAS, or when being very careful about benchmarking</span>
<span class="sd">    linear algebra operations.</span>

<span class="sd">    .. note:: Deprecated in Numpy 1.10</span>
<span class="sd">              The cblas functions have been integrated into the multarray</span>
<span class="sd">              module and restoredot now longer does anything. It will be</span>
<span class="sd">              removed in Numpy 1.11.0.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    alterdot : `restoredot` undoes the effects of `alterdot`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 2014-08-13, 1.10</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;restoredot no longer does anything.&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute tensor dot product along specified axes for arrays &gt;= 1-D.</span>

<span class="sd">    Given two tensors (arrays of dimension greater than or equal to one),</span>
<span class="sd">    `a` and `b`, and an array_like object containing two array_like</span>
<span class="sd">    objects, ``(a_axes, b_axes)``, sum the products of `a`&#39;s and `b`&#39;s</span>
<span class="sd">    elements (components) over the axes specified by ``a_axes`` and</span>
<span class="sd">    ``b_axes``. The third argument can be a single non-negative</span>
<span class="sd">    integer_like scalar, ``N``; if it is such, then the last ``N``</span>
<span class="sd">    dimensions of `a` and the first ``N`` dimensions of `b` are summed</span>
<span class="sd">    over.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : array_like, len(shape) &gt;= 1</span>
<span class="sd">        Tensors to &quot;dot&quot;.</span>

<span class="sd">    axes : int or (2,) array_like</span>
<span class="sd">        * integer_like</span>
<span class="sd">          If an int N, sum over the last N axes of `a` and the first N axes</span>
<span class="sd">          of `b` in order. The sizes of the corresponding axes must match.</span>
<span class="sd">        * (2,) array_like</span>
<span class="sd">          Or, a list of axes to be summed over, first sequence applying to `a`,</span>
<span class="sd">          second to `b`. Both elements array_like must be of the same length.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    dot, einsum</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Three common use cases are:</span>
<span class="sd">        ``axes = 0`` : tensor product $a\otimes b$</span>
<span class="sd">        ``axes = 1`` : tensor dot product $a\cdot b$</span>
<span class="sd">        ``axes = 2`` : (default) tensor double contraction $a:b$</span>

<span class="sd">    When `axes` is integer_like, the sequence for evaluation will be: first</span>
<span class="sd">    the -Nth axis in `a` and 0th axis in `b`, and the -1th axis in `a` and</span>
<span class="sd">    Nth axis in `b` last.</span>

<span class="sd">    When there is more than one axis to sum over - and they are not the last</span>
<span class="sd">    (first) axes of `a` (`b`) - the argument `axes` should consist of</span>
<span class="sd">    two sequences of the same length, with the first axis to sum over given</span>
<span class="sd">    first in both sequences, the second axis second, and so forth.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    A &quot;traditional&quot; example:</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(60.).reshape(3,4,5)</span>
<span class="sd">    &gt;&gt;&gt; b = np.arange(24.).reshape(4,3,2)</span>
<span class="sd">    &gt;&gt;&gt; c = np.tensordot(a,b, axes=([1,0],[0,1]))</span>
<span class="sd">    &gt;&gt;&gt; c.shape</span>
<span class="sd">    (5, 2)</span>
<span class="sd">    &gt;&gt;&gt; c</span>
<span class="sd">    array([[ 4400.,  4730.],</span>
<span class="sd">           [ 4532.,  4874.],</span>
<span class="sd">           [ 4664.,  5018.],</span>
<span class="sd">           [ 4796.,  5162.],</span>
<span class="sd">           [ 4928.,  5306.]])</span>
<span class="sd">    &gt;&gt;&gt; # A slower but equivalent way of computing the same...</span>
<span class="sd">    &gt;&gt;&gt; d = np.zeros((5,2))</span>
<span class="sd">    &gt;&gt;&gt; for i in range(5):</span>
<span class="sd">    ...   for j in range(2):</span>
<span class="sd">    ...     for k in range(3):</span>
<span class="sd">    ...       for n in range(4):</span>
<span class="sd">    ...         d[i,j] += a[k,n,i] * b[n,k,j]</span>
<span class="sd">    &gt;&gt;&gt; c == d</span>
<span class="sd">    array([[ True,  True],</span>
<span class="sd">           [ True,  True],</span>
<span class="sd">           [ True,  True],</span>
<span class="sd">           [ True,  True],</span>
<span class="sd">           [ True,  True]], dtype=bool)</span>

<span class="sd">    An extended example taking advantage of the overloading of + and \\*:</span>

<span class="sd">    &gt;&gt;&gt; a = np.array(range(1, 9))</span>
<span class="sd">    &gt;&gt;&gt; a.shape = (2, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; A = np.array((&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;), dtype=object)</span>
<span class="sd">    &gt;&gt;&gt; A.shape = (2, 2)</span>
<span class="sd">    &gt;&gt;&gt; a; A</span>
<span class="sd">    array([[[1, 2],</span>
<span class="sd">            [3, 4]],</span>
<span class="sd">           [[5, 6],</span>
<span class="sd">            [7, 8]]])</span>
<span class="sd">    array([[a, b],</span>
<span class="sd">           [c, d]], dtype=object)</span>

<span class="sd">    &gt;&gt;&gt; np.tensordot(a, A) # third argument default is 2 for double-contraction</span>
<span class="sd">    array([abbcccdddd, aaaaabbbbbbcccccccdddddddd], dtype=object)</span>

<span class="sd">    &gt;&gt;&gt; np.tensordot(a, A, 1)</span>
<span class="sd">    array([[[acc, bdd],</span>
<span class="sd">            [aaacccc, bbbdddd]],</span>
<span class="sd">           [[aaaaacccccc, bbbbbdddddd],</span>
<span class="sd">            [aaaaaaacccccccc, bbbbbbbdddddddd]]], dtype=object)</span>

<span class="sd">    &gt;&gt;&gt; np.tensordot(a, A, 0) # tensor product (result too long to incl.)</span>
<span class="sd">    array([[[[[a, b],</span>
<span class="sd">              [c, d]],</span>
<span class="sd">              ...</span>

<span class="sd">    &gt;&gt;&gt; np.tensordot(a, A, (0, 1))</span>
<span class="sd">    array([[[abbbbb, cddddd],</span>
<span class="sd">            [aabbbbbb, ccdddddd]],</span>
<span class="sd">           [[aaabbbbbbb, cccddddddd],</span>
<span class="sd">            [aaaabbbbbbbb, ccccdddddddd]]], dtype=object)</span>

<span class="sd">    &gt;&gt;&gt; np.tensordot(a, A, (2, 1))</span>
<span class="sd">    array([[[abb, cdd],</span>
<span class="sd">            [aaabbbb, cccdddd]],</span>
<span class="sd">           [[aaaaabbbbbb, cccccdddddd],</span>
<span class="sd">            [aaaaaaabbbbbbbb, cccccccdddddddd]]], dtype=object)</span>

<span class="sd">    &gt;&gt;&gt; np.tensordot(a, A, ((0, 1), (0, 1)))</span>
<span class="sd">    array([abbbcccccddddddd, aabbbbccccccdddddddd], dtype=object)</span>

<span class="sd">    &gt;&gt;&gt; np.tensordot(a, A, ((2, 1), (1, 0)))</span>
<span class="sd">    array([acccbbdddd, aaaaacccccccbbbbbbdddddddd], dtype=object)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">iter</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">axes_a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">axes</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">axes_b</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">axes</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axes_a</span><span class="p">,</span> <span class="n">axes_b</span> <span class="o">=</span> <span class="n">axes</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">na</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes_a</span><span class="p">)</span>
        <span class="n">axes_a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">axes_a</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">axes_a</span> <span class="o">=</span> <span class="p">[</span><span class="n">axes_a</span><span class="p">]</span>
        <span class="n">na</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes_b</span><span class="p">)</span>
        <span class="n">axes_b</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">axes_b</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">axes_b</span> <span class="o">=</span> <span class="p">[</span><span class="n">axes_b</span><span class="p">]</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">as_</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">nda</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">bs</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">ndb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">equal</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">na</span> <span class="o">!=</span> <span class="n">nb</span><span class="p">:</span>
        <span class="n">equal</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">na</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">as_</span><span class="p">[</span><span class="n">axes_a</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">!=</span> <span class="n">bs</span><span class="p">[</span><span class="n">axes_b</span><span class="p">[</span><span class="n">k</span><span class="p">]]:</span>
                <span class="n">equal</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">axes_a</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">axes_a</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">nda</span>
            <span class="k">if</span> <span class="n">axes_b</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">axes_b</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ndb</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">equal</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;shape-mismatch for sum&quot;</span><span class="p">)</span>

    <span class="c1"># Move the axes to sum over to the end of &quot;a&quot;</span>
    <span class="c1"># and to the front of &quot;b&quot;</span>
    <span class="n">notin</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nda</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes_a</span><span class="p">]</span>
    <span class="n">newaxes_a</span> <span class="o">=</span> <span class="n">notin</span> <span class="o">+</span> <span class="n">axes_a</span>
    <span class="n">N2</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes_a</span><span class="p">:</span>
        <span class="n">N2</span> <span class="o">*=</span> <span class="n">as_</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">newshape_a</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">N2</span><span class="p">)</span>
    <span class="n">olda</span> <span class="o">=</span> <span class="p">[</span><span class="n">as_</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">notin</span><span class="p">]</span>

    <span class="n">notin</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndb</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes_b</span><span class="p">]</span>
    <span class="n">newaxes_b</span> <span class="o">=</span> <span class="n">axes_b</span> <span class="o">+</span> <span class="n">notin</span>
    <span class="n">N2</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes_b</span><span class="p">:</span>
        <span class="n">N2</span> <span class="o">*=</span> <span class="n">bs</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">newshape_b</span> <span class="o">=</span> <span class="p">(</span><span class="n">N2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">oldb</span> <span class="o">=</span> <span class="p">[</span><span class="n">bs</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">notin</span><span class="p">]</span>

    <span class="n">at</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">newaxes_a</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">newshape_a</span><span class="p">)</span>
    <span class="n">bt</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">newaxes_b</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">newshape_b</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">bt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">olda</span> <span class="o">+</span> <span class="n">oldb</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">roll</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Roll array elements along a given axis.</span>

<span class="sd">    Elements that roll beyond the last position are re-introduced at</span>
<span class="sd">    the first.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    shift : int</span>
<span class="sd">        The number of places by which elements are shifted.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which elements are shifted.  By default, the array</span>
<span class="sd">        is flattened before shifting, after which the original</span>
<span class="sd">        shape is restored.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    res : ndarray</span>
<span class="sd">        Output array, with the same shape as `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    rollaxis : Roll the specified axis backwards, until it lies in a</span>
<span class="sd">               given position.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(10)</span>
<span class="sd">    &gt;&gt;&gt; np.roll(x, 2)</span>
<span class="sd">    array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])</span>

<span class="sd">    &gt;&gt;&gt; x2 = np.reshape(x, (2,5))</span>
<span class="sd">    &gt;&gt;&gt; x2</span>
<span class="sd">    array([[0, 1, 2, 3, 4],</span>
<span class="sd">           [5, 6, 7, 8, 9]])</span>
<span class="sd">    &gt;&gt;&gt; np.roll(x2, 1)</span>
<span class="sd">    array([[9, 0, 1, 2, 3],</span>
<span class="sd">           [4, 5, 6, 7, 8]])</span>
<span class="sd">    &gt;&gt;&gt; np.roll(x2, 1, axis=0)</span>
<span class="sd">    array([[5, 6, 7, 8, 9],</span>
<span class="sd">           [0, 1, 2, 3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.roll(x2, 1, axis=1)</span>
<span class="sd">    array([[4, 0, 1, 2, 3],</span>
<span class="sd">           [9, 5, 6, 7, 8]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span>
        <span class="n">reshape</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;axis must be &gt;= 0 and &lt; </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="n">reshape</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="n">shift</span> <span class="o">%=</span> <span class="n">n</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">shift</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">arange</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">shift</span><span class="p">)))</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">reshape</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">rollaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Roll the specified axis backwards, until it lies in a given position.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis : int</span>
<span class="sd">        The axis to roll backwards.  The positions of the other axes do not</span>
<span class="sd">        change relative to one another.</span>
<span class="sd">    start : int, optional</span>
<span class="sd">        The axis is rolled until it lies before this position.  The default,</span>
<span class="sd">        0, results in a &quot;complete&quot; roll.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    res : ndarray</span>
<span class="sd">        For Numpy &gt;= 1.10 a view of `a` is always returned. For earlier</span>
<span class="sd">        Numpy versions a view of `a` is returned only if the order of the</span>
<span class="sd">        axes is changed, otherwise the input array is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    moveaxis : Move array axes to new positions.</span>
<span class="sd">    roll : Roll the elements of an array by a number of positions along a</span>
<span class="sd">        given axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.ones((3,4,5,6))</span>
<span class="sd">    &gt;&gt;&gt; np.rollaxis(a, 3, 1).shape</span>
<span class="sd">    (3, 6, 4, 5)</span>
<span class="sd">    &gt;&gt;&gt; np.rollaxis(a, 2).shape</span>
<span class="sd">    (5, 3, 4, 6)</span>
<span class="sd">    &gt;&gt;&gt; np.rollaxis(a, 1, 4).shape</span>
<span class="sd">    (3, 5, 6, 4)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">+=</span> <span class="n">n</span>
    <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="n">n</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;rollaxis: </span><span class="si">%s</span><span class="s1"> (</span><span class="si">%d</span><span class="s1">) must be &gt;=0 and &lt; </span><span class="si">%d</span><span class="s1">&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">axis</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">):</span>
        <span class="c1"># it&#39;s been removed</span>
        <span class="n">start</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="n">start</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">]</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">axes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">axes</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_validate_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">argname</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="p">[</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">)]</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="o">+</span> <span class="n">ndim</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">builtins</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">ndim</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid axis for this array in `</span><span class="si">%s</span><span class="s1">` argument&#39;</span> <span class="o">%</span>
                         <span class="n">argname</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;repeated axis in `</span><span class="si">%s</span><span class="s1">` argument&#39;</span> <span class="o">%</span> <span class="n">argname</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">axis</span>


<span class="k">def</span> <span class="nf">moveaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Move axes of an array to new positions.</span>

<span class="sd">    Other axes remain in their original order.</span>

<span class="sd">    .. versionadded::1.11.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : np.ndarray</span>
<span class="sd">        The array whose axes should be reordered.</span>
<span class="sd">    source : int or sequence of int</span>
<span class="sd">        Original positions of the axes to move. These must be unique.</span>
<span class="sd">    destination : int or sequence of int</span>
<span class="sd">        Destination positions for each of the original axes. These must also be</span>
<span class="sd">        unique.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : np.ndarray</span>
<span class="sd">        Array with moved axes. This array is a view of the input array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    transpose: Permute the dimensions of an array.</span>
<span class="sd">    swapaxes: Interchange two axes of an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; x = np.zeros((3, 4, 5))</span>
<span class="sd">    &gt;&gt;&gt; np.moveaxis(x, 0, -1).shape</span>
<span class="sd">    (4, 5, 3)</span>
<span class="sd">    &gt;&gt;&gt; np.moveaxis(x, -1, 0).shape</span>
<span class="sd">    (5, 3, 4)</span>

<span class="sd">    These all achieve the same result:</span>

<span class="sd">    &gt;&gt;&gt; np.transpose(x).shape</span>
<span class="sd">    (5, 4, 3)</span>
<span class="sd">    &gt;&gt;&gt; np.swapaxis(x, 0, -1).shape</span>
<span class="sd">    (5, 4, 3)</span>
<span class="sd">    &gt;&gt;&gt; np.moveaxis(x, [0, 1], [-1, -2]).shape</span>
<span class="sd">    (5, 4, 3)</span>
<span class="sd">    &gt;&gt;&gt; np.moveaxis(x, [0, 1, 2], [-1, -2, -3]).shape</span>
<span class="sd">    (5, 4, 3)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># allow duck-array types if they define transpose</span>
        <span class="n">transpose</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">transpose</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">transpose</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">transpose</span>

    <span class="n">source</span> <span class="o">=</span> <span class="n">_validate_axis</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="s1">&#39;source&#39;</span><span class="p">)</span>
    <span class="n">destination</span> <span class="o">=</span> <span class="n">_validate_axis</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="s1">&#39;destination&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">destination</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`source` and `destination` arguments must have &#39;</span>
                         <span class="s1">&#39;the same number of elements&#39;</span><span class="p">)</span>

    <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">source</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">dest</span><span class="p">,</span> <span class="n">src</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">source</span><span class="p">)):</span>
        <span class="n">order</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="c1"># fix hack in scipy which imports this function</span>
<span class="k">def</span> <span class="nf">_move_axis_to_0</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">rollaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axisa</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axisb</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axisc</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the cross product of two (arrays of) vectors.</span>

<span class="sd">    The cross product of `a` and `b` in :math:`R^3` is a vector perpendicular</span>
<span class="sd">    to both `a` and `b`.  If `a` and `b` are arrays of vectors, the vectors</span>
<span class="sd">    are defined by the last axis of `a` and `b` by default, and these axes</span>
<span class="sd">    can have dimensions 2 or 3.  Where the dimension of either `a` or `b` is</span>
<span class="sd">    2, the third component of the input vector is assumed to be zero and the</span>
<span class="sd">    cross product calculated accordingly.  In cases where both input vectors</span>
<span class="sd">    have dimension 2, the z-component of the cross product is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Components of the first vector(s).</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Components of the second vector(s).</span>
<span class="sd">    axisa : int, optional</span>
<span class="sd">        Axis of `a` that defines the vector(s).  By default, the last axis.</span>
<span class="sd">    axisb : int, optional</span>
<span class="sd">        Axis of `b` that defines the vector(s).  By default, the last axis.</span>
<span class="sd">    axisc : int, optional</span>
<span class="sd">        Axis of `c` containing the cross product vector(s).  Ignored if</span>
<span class="sd">        both input vectors have dimension 2, as the return is scalar.</span>
<span class="sd">        By default, the last axis.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        If defined, the axis of `a`, `b` and `c` that defines the vector(s)</span>
<span class="sd">        and cross product(s).  Overrides `axisa`, `axisb` and `axisc`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    c : ndarray</span>
<span class="sd">        Vector cross product(s).</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        When the dimension of the vector(s) in `a` and/or `b` does not</span>
<span class="sd">        equal 2 or 3.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    inner : Inner product</span>
<span class="sd">    outer : Outer product.</span>
<span class="sd">    ix_ : Construct index arrays.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 1.9.0</span>

<span class="sd">    Supports full broadcasting of the inputs.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Vector cross-product.</span>

<span class="sd">    &gt;&gt;&gt; x = [1, 2, 3]</span>
<span class="sd">    &gt;&gt;&gt; y = [4, 5, 6]</span>
<span class="sd">    &gt;&gt;&gt; np.cross(x, y)</span>
<span class="sd">    array([-3,  6, -3])</span>

<span class="sd">    One vector with dimension 2.</span>

<span class="sd">    &gt;&gt;&gt; x = [1, 2]</span>
<span class="sd">    &gt;&gt;&gt; y = [4, 5, 6]</span>
<span class="sd">    &gt;&gt;&gt; np.cross(x, y)</span>
<span class="sd">    array([12, -6, -3])</span>

<span class="sd">    Equivalently:</span>

<span class="sd">    &gt;&gt;&gt; x = [1, 2, 0]</span>
<span class="sd">    &gt;&gt;&gt; y = [4, 5, 6]</span>
<span class="sd">    &gt;&gt;&gt; np.cross(x, y)</span>
<span class="sd">    array([12, -6, -3])</span>

<span class="sd">    Both vectors with dimension 2.</span>

<span class="sd">    &gt;&gt;&gt; x = [1,2]</span>
<span class="sd">    &gt;&gt;&gt; y = [4,5]</span>
<span class="sd">    &gt;&gt;&gt; np.cross(x, y)</span>
<span class="sd">    -3</span>

<span class="sd">    Multiple vector cross-products. Note that the direction of the cross</span>
<span class="sd">    product vector is defined by the `right-hand rule`.</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[1,2,3], [4,5,6]])</span>
<span class="sd">    &gt;&gt;&gt; y = np.array([[4,5,6], [1,2,3]])</span>
<span class="sd">    &gt;&gt;&gt; np.cross(x, y)</span>
<span class="sd">    array([[-3,  6, -3],</span>
<span class="sd">           [ 3, -6,  3]])</span>

<span class="sd">    The orientation of `c` can be changed using the `axisc` keyword.</span>

<span class="sd">    &gt;&gt;&gt; np.cross(x, y, axisc=0)</span>
<span class="sd">    array([[-3,  3],</span>
<span class="sd">           [ 6, -6],</span>
<span class="sd">           [-3,  3]])</span>

<span class="sd">    Change the vector definition of `x` and `y` using `axisa` and `axisb`.</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])</span>
<span class="sd">    &gt;&gt;&gt; y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])</span>
<span class="sd">    &gt;&gt;&gt; np.cross(x, y)</span>
<span class="sd">    array([[ -6,  12,  -6],</span>
<span class="sd">           [  0,   0,   0],</span>
<span class="sd">           [  6, -12,   6]])</span>
<span class="sd">    &gt;&gt;&gt; np.cross(x, y, axisa=0, axisb=0)</span>
<span class="sd">    array([[-24,  48, -24],</span>
<span class="sd">           [-30,  60, -30],</span>
<span class="sd">           [-36,  72, -36]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axisa</span><span class="p">,</span> <span class="n">axisb</span><span class="p">,</span> <span class="n">axisc</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis</span><span class="p">,)</span> <span class="o">*</span> <span class="mi">3</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="c1"># Check axisa and axisb are within bounds</span>
    <span class="n">axis_msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;axis</span><span class="si">{0}</span><span class="s2">&#39; out of bounds&quot;</span>
    <span class="k">if</span> <span class="n">axisa</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">or</span> <span class="n">axisa</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">axis_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">axisb</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">or</span> <span class="n">axisb</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">axis_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">))</span>
    <span class="c1"># Move working axis to the end of the shape</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">rollaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axisa</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">rollaxis</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axisb</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;incompatible dimensions for cross product</span><span class="se">\n</span><span class="s2">&quot;</span>
           <span class="s2">&quot;(dimension must be 2 or 3)&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># Create the output array</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">broadcast</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)</span>
        <span class="c1"># Check axisc is within bounds</span>
        <span class="k">if</span> <span class="n">axisc</span> <span class="o">&lt;</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="ow">or</span> <span class="n">axisc</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">axis_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">))</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">promote_types</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">cp</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># create local aliases for readability</span>
    <span class="n">a0</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">b0</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">cp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">cp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">cp0</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">cp1</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">cp2</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># a0 * b1 - a1 * b0</span>
            <span class="n">multiply</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">cp</span><span class="p">)</span>
            <span class="n">cp</span> <span class="o">-=</span> <span class="n">a1</span> <span class="o">*</span> <span class="n">b0</span>
            <span class="k">return</span> <span class="n">cp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span>
            <span class="c1"># cp0 = a1 * b2 - 0  (a2 = 0)</span>
            <span class="c1"># cp1 = 0 - a0 * b2  (a2 = 0)</span>
            <span class="c1"># cp2 = a0 * b1 - a1 * b0</span>
            <span class="n">multiply</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">cp0</span><span class="p">)</span>
            <span class="n">multiply</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">cp1</span><span class="p">)</span>
            <span class="n">negative</span><span class="p">(</span><span class="n">cp1</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">cp1</span><span class="p">)</span>
            <span class="n">multiply</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">cp2</span><span class="p">)</span>
            <span class="n">cp2</span> <span class="o">-=</span> <span class="n">a1</span> <span class="o">*</span> <span class="n">b0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># cp0 = a1 * b2 - a2 * b1</span>
            <span class="c1"># cp1 = a2 * b0 - a0 * b2</span>
            <span class="c1"># cp2 = a0 * b1 - a1 * b0</span>
            <span class="n">multiply</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">cp0</span><span class="p">)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">a2</span> <span class="o">*</span> <span class="n">b1</span><span class="p">)</span>
            <span class="n">cp0</span> <span class="o">-=</span> <span class="n">tmp</span>
            <span class="n">multiply</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">b0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">cp1</span><span class="p">)</span>
            <span class="n">multiply</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>
            <span class="n">cp1</span> <span class="o">-=</span> <span class="n">tmp</span>
            <span class="n">multiply</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">cp2</span><span class="p">)</span>
            <span class="n">multiply</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>
            <span class="n">cp2</span> <span class="o">-=</span> <span class="n">tmp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="c1"># cp0 = 0 - a2 * b1  (b2 = 0)</span>
            <span class="c1"># cp1 = a2 * b0 - 0  (b2 = 0)</span>
            <span class="c1"># cp2 = a0 * b1 - a1 * b0</span>
            <span class="n">multiply</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">cp0</span><span class="p">)</span>
            <span class="n">negative</span><span class="p">(</span><span class="n">cp0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">cp0</span><span class="p">)</span>
            <span class="n">multiply</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">b0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">cp1</span><span class="p">)</span>
            <span class="n">multiply</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">cp2</span><span class="p">)</span>
            <span class="n">cp2</span> <span class="o">-=</span> <span class="n">a1</span> <span class="o">*</span> <span class="n">b0</span>

    <span class="c1"># This works because we are moving the last axis</span>
    <span class="k">return</span> <span class="n">rollaxis</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axisc</span><span class="p">)</span>

<span class="c1">#Use numarray&#39;s printing function</span>
<span class="kn">from</span> <span class="nn">.arrayprint</span> <span class="k">import</span> <span class="n">array2string</span><span class="p">,</span> <span class="n">get_printoptions</span><span class="p">,</span> <span class="n">set_printoptions</span>

<span class="n">_typelessdata</span> <span class="o">=</span> <span class="p">[</span><span class="n">int_</span><span class="p">,</span> <span class="n">float_</span><span class="p">,</span> <span class="n">complex_</span><span class="p">]</span>
<span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">intc</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">_typelessdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">intc</span><span class="p">)</span>

<span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">longlong</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">_typelessdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">longlong</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">array_repr</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">max_line_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">suppress_small</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the string representation of an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Input array.</span>
<span class="sd">    max_line_width : int, optional</span>
<span class="sd">        The maximum number of columns the string should span. Newline</span>
<span class="sd">        characters split the string appropriately after array elements.</span>
<span class="sd">    precision : int, optional</span>
<span class="sd">        Floating point precision. Default is the current printing precision</span>
<span class="sd">        (usually 8), which can be altered using `set_printoptions`.</span>
<span class="sd">    suppress_small : bool, optional</span>
<span class="sd">        Represent very small numbers as zero, default is False. Very small</span>
<span class="sd">        is defined by `precision`, if the precision is 8 then</span>
<span class="sd">        numbers smaller than 5e-9 are represented as zero.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string : str</span>
<span class="sd">      The string representation of an array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    array_str, array2string, set_printoptions</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.array_repr(np.array([1,2]))</span>
<span class="sd">    &#39;array([1, 2])&#39;</span>
<span class="sd">    &gt;&gt;&gt; np.array_repr(np.ma.array([0.]))</span>
<span class="sd">    &#39;MaskedArray([ 0.])&#39;</span>
<span class="sd">    &gt;&gt;&gt; np.array_repr(np.array([], np.int32))</span>
<span class="sd">    &#39;array([], dtype=int32)&#39;</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([1e-6, 4e-7, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; np.array_repr(x, precision=6, suppress_small=True)</span>
<span class="sd">    &#39;array([ 0.000001,  0.      ,  2.      ,  3.      ])&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,):</span>
        <span class="n">lst</span> <span class="o">=</span> <span class="n">array2string</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">max_line_width</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">suppress_small</span><span class="p">,</span>
                           <span class="s1">&#39;, &#39;</span><span class="p">,</span> <span class="s2">&quot;array(&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># show zero-length shape unless it is (0,)</span>
        <span class="n">lst</span> <span class="o">=</span> <span class="s2">&quot;[], shape=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">),)</span>

    <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">__class__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="n">cName</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cName</span> <span class="o">=</span> <span class="s2">&quot;array&quot;</span>

    <span class="n">skipdtype</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="n">_typelessdata</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">skipdtype</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cName</span><span class="p">,</span> <span class="n">lst</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">typename</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span>
        <span class="c1"># Quote typename in the output if it is &quot;complex&quot;.</span>
        <span class="k">if</span> <span class="n">typename</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">typename</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span> <span class="ow">and</span> <span class="n">typename</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()):</span>
            <span class="n">typename</span> <span class="o">=</span> <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">typename</span>

        <span class="n">lf</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">flexible</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="n">typename</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">typename</span> <span class="o">=</span> <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">lf</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="s2">&quot;array(&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cName</span> <span class="o">+</span> <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">dtype=</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">lf</span><span class="p">,</span> <span class="n">typename</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">array_str</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">max_line_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">suppress_small</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a string representation of the data in an array.</span>

<span class="sd">    The data in the array is returned as a single string.  This function is</span>
<span class="sd">    similar to `array_repr`, the difference being that `array_repr` also</span>
<span class="sd">    returns information on the kind of array and its data type.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        Input array.</span>
<span class="sd">    max_line_width : int, optional</span>
<span class="sd">        Inserts newlines if text is longer than `max_line_width`.  The</span>
<span class="sd">        default is, indirectly, 75.</span>
<span class="sd">    precision : int, optional</span>
<span class="sd">        Floating point precision.  Default is the current printing precision</span>
<span class="sd">        (usually 8), which can be altered using `set_printoptions`.</span>
<span class="sd">    suppress_small : bool, optional</span>
<span class="sd">        Represent numbers &quot;very close&quot; to zero as zero; default is False.</span>
<span class="sd">        Very close is defined by precision: if the precision is 8, e.g.,</span>
<span class="sd">        numbers smaller (in absolute value) than 5e-9 are represented as</span>
<span class="sd">        zero.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    array2string, array_repr, set_printoptions</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.array_str(np.arange(3))</span>
<span class="sd">    &#39;[0 1 2]&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">array2string</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">max_line_width</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">suppress_small</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">set_string_function</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">repr</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set a Python function to be used when pretty printing arrays.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f : function or None</span>
<span class="sd">        Function to be used to pretty print arrays. The function should expect</span>
<span class="sd">        a single array argument and return a string of the representation of</span>
<span class="sd">        the array. If None, the function is reset to the default NumPy function</span>
<span class="sd">        to print arrays.</span>
<span class="sd">    repr : bool, optional</span>
<span class="sd">        If True (default), the function for pretty printing (``__repr__``)</span>
<span class="sd">        is set, if False the function that returns the default string</span>
<span class="sd">        representation (``__str__``) is set.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    set_printoptions, get_printoptions</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; def pprint(arr):</span>
<span class="sd">    ...     return &#39;HA! - What are you going to do now?&#39;</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; np.set_string_function(pprint)</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(10)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    HA! - What are you going to do now?</span>
<span class="sd">    &gt;&gt;&gt; print(a)</span>
<span class="sd">    [0 1 2 3 4 5 6 7 8 9]</span>

<span class="sd">    We can reset the function to the default:</span>

<span class="sd">    &gt;&gt;&gt; np.set_string_function(None)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>

<span class="sd">    `repr` affects either pretty printing or normal string representation.</span>
<span class="sd">    Note that ``__repr__`` is still affected by setting ``__str__``</span>
<span class="sd">    because the width of each array element in the returned string becomes</span>
<span class="sd">    equal to the length of the result of ``__str__()``.</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(4)</span>
<span class="sd">    &gt;&gt;&gt; np.set_string_function(lambda x:&#39;random&#39;, repr=False)</span>
<span class="sd">    &gt;&gt;&gt; x.__str__()</span>
<span class="sd">    &#39;random&#39;</span>
<span class="sd">    &gt;&gt;&gt; x.__repr__()</span>
<span class="sd">    &#39;array([     0,      1,      2,      3])&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">repr</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">set_string_function</span><span class="p">(</span><span class="n">array_repr</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">set_string_function</span><span class="p">(</span><span class="n">array_str</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">set_string_function</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">repr</span><span class="p">)</span>

<span class="n">set_string_function</span><span class="p">(</span><span class="n">array_str</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">set_string_function</span><span class="p">(</span><span class="n">array_repr</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">little_endian</span> <span class="o">=</span> <span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;little&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an array representing the indices of a grid.</span>

<span class="sd">    Compute an array where the subarrays contain index values 0,1,...</span>
<span class="sd">    varying only along the corresponding axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dimensions : sequence of ints</span>
<span class="sd">        The shape of the grid.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        Data type of the result.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    grid : ndarray</span>
<span class="sd">        The array of grid indices,</span>
<span class="sd">        ``grid.shape = (len(dimensions),) + tuple(dimensions)``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mgrid, meshgrid</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The output shape is obtained by prepending the number of dimensions</span>
<span class="sd">    in front of the tuple of dimensions, i.e. if `dimensions` is a tuple</span>
<span class="sd">    ``(r0, ..., rN-1)`` of length ``N``, the output shape is</span>
<span class="sd">    ``(N,r0,...,rN-1)``.</span>

<span class="sd">    The subarrays ``grid[k]`` contains the N-D array of indices along the</span>
<span class="sd">    ``k-th`` axis. Explicitly::</span>

<span class="sd">        grid[k,i0,i1,...,iN-1] = ik</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; grid = np.indices((2, 3))</span>
<span class="sd">    &gt;&gt;&gt; grid.shape</span>
<span class="sd">    (2, 2, 3)</span>
<span class="sd">    &gt;&gt;&gt; grid[0]        # row indices</span>
<span class="sd">    array([[0, 0, 0],</span>
<span class="sd">           [1, 1, 1]])</span>
<span class="sd">    &gt;&gt;&gt; grid[1]        # column indices</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [0, 1, 2]])</span>

<span class="sd">    The indices can be used as an index into an array.</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(20).reshape(5, 4)</span>
<span class="sd">    &gt;&gt;&gt; row, col = np.indices((2, 3))</span>
<span class="sd">    &gt;&gt;&gt; x[row, col]</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [4, 5, 6]])</span>

<span class="sd">    Note that it would be more straightforward in the above example to</span>
<span class="sd">    extract the required elements directly with ``x[:2, :3]``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dimensions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">empty</span><span class="p">((</span><span class="n">N</span><span class="p">,)</span><span class="o">+</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span><span class="p">,)</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">newdim</span> <span class="o">=</span> <span class="n">dimensions</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">dimensions</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">newdim</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="n">add</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="k">def</span> <span class="nf">fromfunction</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct an array by executing a function over each coordinate.</span>

<span class="sd">    The resulting array therefore has a value ``fn(x, y, z)`` at</span>
<span class="sd">    coordinate ``(x, y, z)``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    function : callable</span>
<span class="sd">        The function is called with N parameters, where N is the rank of</span>
<span class="sd">        `shape`.  Each parameter represents the coordinates of the array</span>
<span class="sd">        varying along a specific axis.  For example, if `shape`</span>
<span class="sd">        were ``(2, 2)``, then the parameters in turn be (0, 0), (0, 1),</span>
<span class="sd">        (1, 0), (1, 1).</span>
<span class="sd">    shape : (N,) tuple of ints</span>
<span class="sd">        Shape of the output array, which also determines the shape of</span>
<span class="sd">        the coordinate arrays passed to `function`.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Data-type of the coordinate arrays passed to `function`.</span>
<span class="sd">        By default, `dtype` is float.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fromfunction : any</span>
<span class="sd">        The result of the call to `function` is passed back directly.</span>
<span class="sd">        Therefore the shape of `fromfunction` is completely determined by</span>
<span class="sd">        `function`.  If `function` returns a scalar value, the shape of</span>
<span class="sd">        `fromfunction` would match the `shape` parameter.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    indices, meshgrid</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Keywords other than `dtype` are passed to `function`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)</span>
<span class="sd">    array([[ True, False, False],</span>
<span class="sd">           [False,  True, False],</span>
<span class="sd">           [False, False,  True]], dtype=bool)</span>

<span class="sd">    &gt;&gt;&gt; np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [1, 2, 3],</span>
<span class="sd">           [2, 3, 4]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">isscalar</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if the type of `num` is a scalar type.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num : any</span>
<span class="sd">        Input argument, can be of any type and shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    val : bool</span>
<span class="sd">        True if `num` is a scalar type, False if it is not.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.isscalar(3.1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.isscalar([3.1])</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; np.isscalar(False)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">generic</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ScalarType</span>

<span class="n">_lkup</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;0&#39;</span><span class="p">:</span><span class="s1">&#39;0000&#39;</span><span class="p">,</span>
    <span class="s1">&#39;1&#39;</span><span class="p">:</span><span class="s1">&#39;0001&#39;</span><span class="p">,</span>
    <span class="s1">&#39;2&#39;</span><span class="p">:</span><span class="s1">&#39;0010&#39;</span><span class="p">,</span>
    <span class="s1">&#39;3&#39;</span><span class="p">:</span><span class="s1">&#39;0011&#39;</span><span class="p">,</span>
    <span class="s1">&#39;4&#39;</span><span class="p">:</span><span class="s1">&#39;0100&#39;</span><span class="p">,</span>
    <span class="s1">&#39;5&#39;</span><span class="p">:</span><span class="s1">&#39;0101&#39;</span><span class="p">,</span>
    <span class="s1">&#39;6&#39;</span><span class="p">:</span><span class="s1">&#39;0110&#39;</span><span class="p">,</span>
    <span class="s1">&#39;7&#39;</span><span class="p">:</span><span class="s1">&#39;0111&#39;</span><span class="p">,</span>
    <span class="s1">&#39;8&#39;</span><span class="p">:</span><span class="s1">&#39;1000&#39;</span><span class="p">,</span>
    <span class="s1">&#39;9&#39;</span><span class="p">:</span><span class="s1">&#39;1001&#39;</span><span class="p">,</span>
    <span class="s1">&#39;a&#39;</span><span class="p">:</span><span class="s1">&#39;1010&#39;</span><span class="p">,</span>
    <span class="s1">&#39;b&#39;</span><span class="p">:</span><span class="s1">&#39;1011&#39;</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span><span class="s1">&#39;1100&#39;</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span><span class="s1">&#39;1101&#39;</span><span class="p">,</span>
    <span class="s1">&#39;e&#39;</span><span class="p">:</span><span class="s1">&#39;1110&#39;</span><span class="p">,</span>
    <span class="s1">&#39;f&#39;</span><span class="p">:</span><span class="s1">&#39;1111&#39;</span><span class="p">,</span>
    <span class="s1">&#39;A&#39;</span><span class="p">:</span><span class="s1">&#39;1010&#39;</span><span class="p">,</span>
    <span class="s1">&#39;B&#39;</span><span class="p">:</span><span class="s1">&#39;1011&#39;</span><span class="p">,</span>
    <span class="s1">&#39;C&#39;</span><span class="p">:</span><span class="s1">&#39;1100&#39;</span><span class="p">,</span>
    <span class="s1">&#39;D&#39;</span><span class="p">:</span><span class="s1">&#39;1101&#39;</span><span class="p">,</span>
    <span class="s1">&#39;E&#39;</span><span class="p">:</span><span class="s1">&#39;1110&#39;</span><span class="p">,</span>
    <span class="s1">&#39;F&#39;</span><span class="p">:</span><span class="s1">&#39;1111&#39;</span><span class="p">,</span>
    <span class="s1">&#39;L&#39;</span><span class="p">:</span><span class="s1">&#39;&#39;</span><span class="p">}</span>

<span class="k">def</span> <span class="nf">binary_repr</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the binary representation of the input number as a string.</span>

<span class="sd">    For negative numbers, if width is not given, a minus sign is added to the</span>
<span class="sd">    front. If width is given, the two&#39;s complement of the number is</span>
<span class="sd">    returned, with respect to that width.</span>

<span class="sd">    In a two&#39;s-complement system negative numbers are represented by the two&#39;s</span>
<span class="sd">    complement of the absolute value. This is the most common method of</span>
<span class="sd">    representing signed integers on computers [1]_. A N-bit two&#39;s-complement</span>
<span class="sd">    system can represent every integer in the range</span>
<span class="sd">    :math:`-2^{N-1}` to :math:`+2^{N-1}-1`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num : int</span>
<span class="sd">        Only an integer decimal number can be used.</span>
<span class="sd">    width : int, optional</span>
<span class="sd">        The length of the returned string if `num` is positive, the length of</span>
<span class="sd">        the two&#39;s complement if `num` is negative.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bin : str</span>
<span class="sd">        Binary representation of `num` or two&#39;s complement of `num`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    base_repr: Return a string representation of a number in the given base</span>
<span class="sd">               system.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `binary_repr` is equivalent to using `base_repr` with base 2, but about 25x</span>
<span class="sd">    faster.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia, &quot;Two&#39;s complement&quot;,</span>
<span class="sd">        http://en.wikipedia.org/wiki/Two&#39;s_complement</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.binary_repr(3)</span>
<span class="sd">    &#39;11&#39;</span>
<span class="sd">    &gt;&gt;&gt; np.binary_repr(-3)</span>
<span class="sd">    &#39;-11&#39;</span>
<span class="sd">    &gt;&gt;&gt; np.binary_repr(3, width=4)</span>
<span class="sd">    &#39;0011&#39;</span>

<span class="sd">    The two&#39;s complement is returned when the input number is negative and</span>
<span class="sd">    width is specified:</span>

<span class="sd">    &gt;&gt;&gt; np.binary_repr(-3, width=4)</span>
<span class="sd">    &#39;1101&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># &#39; &lt;-- unbreak Emacs fontification</span>
    <span class="n">sign</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
            <span class="n">num</span> <span class="o">=</span> <span class="o">-</span><span class="n">num</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># replace num with its 2-complement</span>
            <span class="n">num</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">width</span> <span class="o">+</span> <span class="n">num</span>
    <span class="k">elif</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;0&#39;</span><span class="o">*</span><span class="p">(</span><span class="n">width</span> <span class="ow">or</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ostr</span> <span class="o">=</span> <span class="nb">hex</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="nb">bin</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">_lkup</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">ostr</span><span class="p">[</span><span class="mi">2</span><span class="p">:]])</span>
    <span class="nb">bin</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">bin</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="n">width</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sign</span> <span class="o">+</span> <span class="nb">bin</span>

<span class="k">def</span> <span class="nf">base_repr</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a string representation of a number in the given base system.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    number : int</span>
<span class="sd">        The value to convert. Only positive values are handled.</span>
<span class="sd">    base : int, optional</span>
<span class="sd">        Convert `number` to the `base` number system. The valid range is 2-36,</span>
<span class="sd">        the default value is 2.</span>
<span class="sd">    padding : int, optional</span>
<span class="sd">        Number of zeros padded on the left. Default is 0 (no padding).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : str</span>
<span class="sd">        String representation of `number` in `base` system.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    binary_repr : Faster version of `base_repr` for base 2.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.base_repr(5)</span>
<span class="sd">    &#39;101&#39;</span>
<span class="sd">    &gt;&gt;&gt; np.base_repr(6, 5)</span>
<span class="sd">    &#39;11&#39;</span>
<span class="sd">    &gt;&gt;&gt; np.base_repr(7, base=5, padding=3)</span>
<span class="sd">    &#39;00012&#39;</span>

<span class="sd">    &gt;&gt;&gt; np.base_repr(10, base=16)</span>
<span class="sd">    &#39;A&#39;</span>
<span class="sd">    &gt;&gt;&gt; np.base_repr(32, base=16)</span>
<span class="sd">    &#39;20&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">digits</span> <span class="o">=</span> <span class="s1">&#39;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</span>
    <span class="k">if</span> <span class="n">base</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">digits</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bases greater than 36 not handled in base_repr.&quot;</span><span class="p">)</span>

    <span class="n">num</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">num</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">digits</span><span class="p">[</span><span class="n">num</span> <span class="o">%</span> <span class="n">base</span><span class="p">])</span>
        <span class="n">num</span> <span class="o">//=</span> <span class="n">base</span>
    <span class="k">if</span> <span class="n">padding</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;0&#39;</span> <span class="o">*</span> <span class="n">padding</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">number</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">res</span> <span class="ow">or</span> <span class="s1">&#39;0&#39;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">file</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper around cPickle.load which accepts either a file-like object or</span>
<span class="sd">    a filename.</span>

<span class="sd">    Note that the NumPy binary format is not based on pickle/cPickle anymore.</span>
<span class="sd">    For details on the preferred way of loading and saving files, see `load`</span>
<span class="sd">    and `save`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    load, save</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)):</span>
        <span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>

<span class="c1"># These are all essentially abbreviations</span>
<span class="c1"># These might wind up in a special abbreviations module</span>

<span class="k">def</span> <span class="nf">_maketup</span><span class="p">(</span><span class="n">descr</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">dtype</span><span class="p">(</span><span class="n">descr</span><span class="p">)</span>
    <span class="c1"># Place val in all scalar tuples:</span>
    <span class="n">fields</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">fields</span>
    <span class="k">if</span> <span class="n">fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">_maketup</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dt</span><span class="o">.</span><span class="n">names</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">identity</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the identity array.</span>

<span class="sd">    The identity array is a square array with ones on</span>
<span class="sd">    the main diagonal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Number of rows (and columns) in `n` x `n` output.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Data-type of the output.  Defaults to ``float``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        `n` x `n` array with its main diagonal set to one,</span>
<span class="sd">        and all other elements 0.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.identity(3)</span>
<span class="sd">    array([[ 1.,  0.,  0.],</span>
<span class="sd">           [ 0.,  1.,  0.],</span>
<span class="sd">           [ 0.,  0.,  1.]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">eye</span>
    <span class="k">return</span> <span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1.e-5</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1.e-8</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if two arrays are element-wise equal within a tolerance.</span>

<span class="sd">    The tolerance values are positive, typically very small numbers.  The</span>
<span class="sd">    relative difference (`rtol` * abs(`b`)) and the absolute difference</span>
<span class="sd">    `atol` are added together to compare against the absolute difference</span>
<span class="sd">    between `a` and `b`.</span>

<span class="sd">    If either array contains one or more NaNs, False is returned.</span>
<span class="sd">    Infs are treated as equal if they are in the same place and of the same</span>
<span class="sd">    sign in both arrays.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : array_like</span>
<span class="sd">        Input arrays to compare.</span>
<span class="sd">    rtol : float</span>
<span class="sd">        The relative tolerance parameter (see Notes).</span>
<span class="sd">    atol : float</span>
<span class="sd">        The absolute tolerance parameter (see Notes).</span>
<span class="sd">    equal_nan : bool</span>
<span class="sd">        Whether to compare NaN&#39;s as equal.  If True, NaN&#39;s in `a` will be</span>
<span class="sd">        considered equal to NaN&#39;s in `b` in the output array.</span>

<span class="sd">        .. versionadded:: 1.10.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    allclose : bool</span>
<span class="sd">        Returns True if the two arrays are equal within the given</span>
<span class="sd">        tolerance; False otherwise.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    isclose, all, any</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If the following equation is element-wise True, then allclose returns</span>
<span class="sd">    True.</span>

<span class="sd">     absolute(`a` - `b`) &lt;= (`atol` + `rtol` * absolute(`b`))</span>

<span class="sd">    The above equation is not symmetric in `a` and `b`, so that</span>
<span class="sd">    `allclose(a, b)` might be different from `allclose(b, a)` in</span>
<span class="sd">    some rare cases.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.allclose([1e10,1e-7], [1.00001e10,1e-8])</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; np.allclose([1e10,1e-8], [1.00001e10,1e-9])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.allclose([1e10,1e-8], [1.0001e10,1e-9])</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; np.allclose([1.0, np.nan], [1.0, np.nan])</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">isclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="n">equal_nan</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

<div class="viewcode-block" id="isclose"><a class="viewcode-back" href="../../../clustering_metrics.fixes.html#clustering_metrics.fixes.isclose">[docs]</a><span class="k">def</span> <span class="nf">isclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1.e-5</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1.e-8</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a boolean array where two arrays are element-wise equal within a</span>
<span class="sd">    tolerance.</span>

<span class="sd">    The tolerance values are positive, typically very small numbers.  The</span>
<span class="sd">    relative difference (`rtol` * abs(`b`)) and the absolute difference</span>
<span class="sd">    `atol` are added together to compare against the absolute difference</span>
<span class="sd">    between `a` and `b`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : array_like</span>
<span class="sd">        Input arrays to compare.</span>
<span class="sd">    rtol : float</span>
<span class="sd">        The relative tolerance parameter (see Notes).</span>
<span class="sd">    atol : float</span>
<span class="sd">        The absolute tolerance parameter (see Notes).</span>
<span class="sd">    equal_nan : bool</span>
<span class="sd">        Whether to compare NaN&#39;s as equal.  If True, NaN&#39;s in `a` will be</span>
<span class="sd">        considered equal to NaN&#39;s in `b` in the output array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : array_like</span>
<span class="sd">        Returns a boolean array of where `a` and `b` are equal within the</span>
<span class="sd">        given tolerance. If both `a` and `b` are scalars, returns a single</span>
<span class="sd">        boolean value.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    allclose</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 1.7.0</span>

<span class="sd">    For finite values, isclose uses the following equation to test whether</span>
<span class="sd">    two floating point values are equivalent.</span>

<span class="sd">     absolute(`a` - `b`) &lt;= (`atol` + `rtol` * absolute(`b`))</span>

<span class="sd">    The above equation is not symmetric in `a` and `b`, so that</span>
<span class="sd">    `isclose(a, b)` might be different from `isclose(b, a)` in</span>
<span class="sd">    some rare cases.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.isclose([1e10,1e-7], [1.00001e10,1e-8])</span>
<span class="sd">    array([True, False])</span>
<span class="sd">    &gt;&gt;&gt; np.isclose([1e10,1e-8], [1.00001e10,1e-9])</span>
<span class="sd">    array([True, True])</span>
<span class="sd">    &gt;&gt;&gt; np.isclose([1e10,1e-8], [1.0001e10,1e-9])</span>
<span class="sd">    array([False, True])</span>
<span class="sd">    &gt;&gt;&gt; np.isclose([1.0, np.nan], [1.0, np.nan])</span>
<span class="sd">    array([True, False])</span>
<span class="sd">    &gt;&gt;&gt; np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)</span>
<span class="sd">    array([True, True])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">within_tol</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">less_equal</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">),</span> <span class="n">atol</span> <span class="o">+</span> <span class="n">rtol</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).</span>
    <span class="c1"># This will cause casting of x later. Also, make sure to allow subclasses</span>
    <span class="c1"># (e.g., for numpy.ma).</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">xfin</span> <span class="o">=</span> <span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">yfin</span> <span class="o">=</span> <span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">xfin</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">yfin</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">within_tol</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">finite</span> <span class="o">=</span> <span class="n">xfin</span> <span class="o">&amp;</span> <span class="n">yfin</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">finite</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Because we&#39;re using boolean indexing, x &amp; y must be the same shape.</span>
        <span class="c1"># Ideally, we&#39;d just do x, y = broadcast_arrays(x, y). It&#39;s in</span>
        <span class="c1"># lib.stride_tricks, though, so we can&#39;t import it here.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">ones_like</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">ones_like</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span>
        <span class="c1"># Avoid subtraction with infinite/nan values...</span>
        <span class="n">cond</span><span class="p">[</span><span class="n">finite</span><span class="p">]</span> <span class="o">=</span> <span class="n">within_tol</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">finite</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">finite</span><span class="p">],</span> <span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span><span class="p">)</span>
        <span class="c1"># Check for equality of infinite values...</span>
        <span class="n">cond</span><span class="p">[</span><span class="o">~</span><span class="n">finite</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">finite</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="o">~</span><span class="n">finite</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">equal_nan</span><span class="p">:</span>
            <span class="c1"># Make NaN == NaN</span>
            <span class="n">both_nan</span> <span class="o">=</span> <span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">isnan</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">cond</span><span class="p">[</span><span class="n">both_nan</span><span class="p">]</span> <span class="o">=</span> <span class="n">both_nan</span><span class="p">[</span><span class="n">both_nan</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cond</span></div>

<span class="k">def</span> <span class="nf">array_equal</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    True if two arrays have the same shape and elements, False otherwise.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a1, a2 : array_like</span>
<span class="sd">        Input arrays.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : bool</span>
<span class="sd">        Returns True if the arrays are equal.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    allclose: Returns True if two arrays are element-wise equal within a</span>
<span class="sd">              tolerance.</span>
<span class="sd">    array_equiv: Returns True if input arrays are shape consistent and all</span>
<span class="sd">                 elements equal.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.array_equal([1, 2], [1, 2])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.array_equal(np.array([1, 2]), np.array([1, 2]))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.array_equal([1, 2], [1, 2, 3])</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; np.array_equal([1, 2], [1, 4])</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a1</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">a1</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">a2</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">a1</span> <span class="o">==</span> <span class="n">a2</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">array_equiv</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if input arrays are shape consistent and all elements equal.</span>

<span class="sd">    Shape consistent means they are either the same shape, or one input array</span>
<span class="sd">    can be broadcasted to create the same shape as the other one.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a1, a2 : array_like</span>
<span class="sd">        Input arrays.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : bool</span>
<span class="sd">        True if equivalent, False otherwise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.array_equiv([1, 2], [1, 2])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.array_equiv([1, 2], [1, 3])</span>
<span class="sd">    False</span>

<span class="sd">    Showing the shape equivalence:</span>

<span class="sd">    &gt;&gt;&gt; np.array_equiv([1, 2], [[1, 2], [1, 2]])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; np.array_equiv([1, 2], [[1, 2], [1, 3]])</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a1</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">multiarray</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">a1</span> <span class="o">==</span> <span class="n">a2</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>


<span class="n">_errdict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;ignore&quot;</span><span class="p">:</span><span class="n">ERR_IGNORE</span><span class="p">,</span>
            <span class="s2">&quot;warn&quot;</span><span class="p">:</span><span class="n">ERR_WARN</span><span class="p">,</span>
            <span class="s2">&quot;raise&quot;</span><span class="p">:</span><span class="n">ERR_RAISE</span><span class="p">,</span>
            <span class="s2">&quot;call&quot;</span><span class="p">:</span><span class="n">ERR_CALL</span><span class="p">,</span>
            <span class="s2">&quot;print&quot;</span><span class="p">:</span><span class="n">ERR_PRINT</span><span class="p">,</span>
            <span class="s2">&quot;log&quot;</span><span class="p">:</span><span class="n">ERR_LOG</span><span class="p">}</span>

<span class="n">_errdict_rev</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">_errdict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
    <span class="n">_errdict_rev</span><span class="p">[</span><span class="n">_errdict</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span> <span class="o">=</span> <span class="n">key</span>
<span class="k">del</span> <span class="n">key</span>

<span class="k">def</span> <span class="nf">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">divide</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">over</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">under</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set how floating-point errors are handled.</span>

<span class="sd">    Note that operations on integer scalar types (such as `int16`) are</span>
<span class="sd">    handled like floating point, and are affected by these settings.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    all : {&#39;ignore&#39;, &#39;warn&#39;, &#39;raise&#39;, &#39;call&#39;, &#39;print&#39;, &#39;log&#39;}, optional</span>
<span class="sd">        Set treatment for all types of floating-point errors at once:</span>

<span class="sd">        - ignore: Take no action when the exception occurs.</span>
<span class="sd">        - warn: Print a `RuntimeWarning` (via the Python `warnings` module).</span>
<span class="sd">        - raise: Raise a `FloatingPointError`.</span>
<span class="sd">        - call: Call a function specified using the `seterrcall` function.</span>
<span class="sd">        - print: Print a warning directly to ``stdout``.</span>
<span class="sd">        - log: Record error in a Log object specified by `seterrcall`.</span>

<span class="sd">        The default is not to change the current behavior.</span>
<span class="sd">    divide : {&#39;ignore&#39;, &#39;warn&#39;, &#39;raise&#39;, &#39;call&#39;, &#39;print&#39;, &#39;log&#39;}, optional</span>
<span class="sd">        Treatment for division by zero.</span>
<span class="sd">    over : {&#39;ignore&#39;, &#39;warn&#39;, &#39;raise&#39;, &#39;call&#39;, &#39;print&#39;, &#39;log&#39;}, optional</span>
<span class="sd">        Treatment for floating-point overflow.</span>
<span class="sd">    under : {&#39;ignore&#39;, &#39;warn&#39;, &#39;raise&#39;, &#39;call&#39;, &#39;print&#39;, &#39;log&#39;}, optional</span>
<span class="sd">        Treatment for floating-point underflow.</span>
<span class="sd">    invalid : {&#39;ignore&#39;, &#39;warn&#39;, &#39;raise&#39;, &#39;call&#39;, &#39;print&#39;, &#39;log&#39;}, optional</span>
<span class="sd">        Treatment for invalid floating-point operation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    old_settings : dict</span>
<span class="sd">        Dictionary containing the old settings.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    seterrcall : Set a callback function for the &#39;call&#39; mode.</span>
<span class="sd">    geterr, geterrcall, errstate</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The floating-point exceptions are defined in the IEEE 754 standard [1]:</span>

<span class="sd">    - Division by zero: infinite result obtained from finite numbers.</span>
<span class="sd">    - Overflow: result too large to be expressed.</span>
<span class="sd">    - Underflow: result so close to zero that some precision</span>
<span class="sd">      was lost.</span>
<span class="sd">    - Invalid operation: result is not an expressible number, typically</span>
<span class="sd">      indicates that a NaN was produced.</span>

<span class="sd">    .. [1] http://en.wikipedia.org/wiki/IEEE_754</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; old_settings = np.seterr(all=&#39;ignore&#39;)  #seterr to known value</span>
<span class="sd">    &gt;&gt;&gt; np.seterr(over=&#39;raise&#39;)</span>
<span class="sd">    {&#39;over&#39;: &#39;ignore&#39;, &#39;divide&#39;: &#39;ignore&#39;, &#39;invalid&#39;: &#39;ignore&#39;,</span>
<span class="sd">     &#39;under&#39;: &#39;ignore&#39;}</span>
<span class="sd">    &gt;&gt;&gt; np.seterr(**old_settings)  # reset to default</span>
<span class="sd">    {&#39;over&#39;: &#39;raise&#39;, &#39;divide&#39;: &#39;ignore&#39;, &#39;invalid&#39;: &#39;ignore&#39;, &#39;under&#39;: &#39;ignore&#39;}</span>

<span class="sd">    &gt;&gt;&gt; np.int16(32000) * np.int16(3)</span>
<span class="sd">    30464</span>
<span class="sd">    &gt;&gt;&gt; old_settings = np.seterr(all=&#39;warn&#39;, over=&#39;raise&#39;)</span>
<span class="sd">    &gt;&gt;&gt; np.int16(32000) * np.int16(3)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="sd">    FloatingPointError: overflow encountered in short_scalars</span>

<span class="sd">    &gt;&gt;&gt; old_settings = np.seterr(all=&#39;print&#39;)</span>
<span class="sd">    &gt;&gt;&gt; np.geterr()</span>
<span class="sd">    {&#39;over&#39;: &#39;print&#39;, &#39;divide&#39;: &#39;print&#39;, &#39;invalid&#39;: &#39;print&#39;, &#39;under&#39;: &#39;print&#39;}</span>
<span class="sd">    &gt;&gt;&gt; np.int16(32000) * np.int16(3)</span>
<span class="sd">    Warning: overflow encountered in short_scalars</span>
<span class="sd">    30464</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pyvals</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">geterrobj</span><span class="p">()</span>
    <span class="n">old</span> <span class="o">=</span> <span class="n">geterr</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">divide</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">divide</span> <span class="o">=</span> <span class="nb">all</span> <span class="ow">or</span> <span class="n">old</span><span class="p">[</span><span class="s1">&#39;divide&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">over</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">over</span> <span class="o">=</span> <span class="nb">all</span> <span class="ow">or</span> <span class="n">old</span><span class="p">[</span><span class="s1">&#39;over&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">under</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">under</span> <span class="o">=</span> <span class="nb">all</span> <span class="ow">or</span> <span class="n">old</span><span class="p">[</span><span class="s1">&#39;under&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">invalid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">invalid</span> <span class="o">=</span> <span class="nb">all</span> <span class="ow">or</span> <span class="n">old</span><span class="p">[</span><span class="s1">&#39;invalid&#39;</span><span class="p">]</span>

    <span class="n">maskvalue</span> <span class="o">=</span> <span class="p">((</span><span class="n">_errdict</span><span class="p">[</span><span class="n">divide</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">SHIFT_DIVIDEBYZERO</span><span class="p">)</span> <span class="o">+</span>
                 <span class="p">(</span><span class="n">_errdict</span><span class="p">[</span><span class="n">over</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">SHIFT_OVERFLOW</span><span class="p">)</span> <span class="o">+</span>
                 <span class="p">(</span><span class="n">_errdict</span><span class="p">[</span><span class="n">under</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">SHIFT_UNDERFLOW</span><span class="p">)</span> <span class="o">+</span>
                 <span class="p">(</span><span class="n">_errdict</span><span class="p">[</span><span class="n">invalid</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">SHIFT_INVALID</span><span class="p">))</span>

    <span class="n">pyvals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">maskvalue</span>
    <span class="n">umath</span><span class="o">.</span><span class="n">seterrobj</span><span class="p">(</span><span class="n">pyvals</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">old</span>


<span class="k">def</span> <span class="nf">geterr</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the current way of handling floating-point errors.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    res : dict</span>
<span class="sd">        A dictionary with keys &quot;divide&quot;, &quot;over&quot;, &quot;under&quot;, and &quot;invalid&quot;,</span>
<span class="sd">        whose values are from the strings &quot;ignore&quot;, &quot;print&quot;, &quot;log&quot;, &quot;warn&quot;,</span>
<span class="sd">        &quot;raise&quot;, and &quot;call&quot;. The keys represent possible floating-point</span>
<span class="sd">        exceptions, and the values define how these exceptions are handled.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    geterrcall, seterr, seterrcall</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For complete documentation of the types of floating-point exceptions and</span>
<span class="sd">    treatment options, see `seterr`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.geterr()</span>
<span class="sd">    {&#39;over&#39;: &#39;warn&#39;, &#39;divide&#39;: &#39;warn&#39;, &#39;invalid&#39;: &#39;warn&#39;,</span>
<span class="sd">    &#39;under&#39;: &#39;ignore&#39;}</span>
<span class="sd">    &gt;&gt;&gt; np.arange(3.) / np.arange(3.)</span>
<span class="sd">    array([ NaN,   1.,   1.])</span>

<span class="sd">    &gt;&gt;&gt; oldsettings = np.seterr(all=&#39;warn&#39;, over=&#39;raise&#39;)</span>
<span class="sd">    &gt;&gt;&gt; np.geterr()</span>
<span class="sd">    {&#39;over&#39;: &#39;raise&#39;, &#39;divide&#39;: &#39;warn&#39;, &#39;invalid&#39;: &#39;warn&#39;, &#39;under&#39;: &#39;warn&#39;}</span>
<span class="sd">    &gt;&gt;&gt; np.arange(3.) / np.arange(3.)</span>
<span class="sd">    __main__:1: RuntimeWarning: invalid value encountered in divide</span>
<span class="sd">    array([ NaN,   1.,   1.])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">maskvalue</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">geterrobj</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="mi">7</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">maskvalue</span> <span class="o">&gt;&gt;</span> <span class="n">SHIFT_DIVIDEBYZERO</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span>
    <span class="n">res</span><span class="p">[</span><span class="s1">&#39;divide&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_errdict_rev</span><span class="p">[</span><span class="n">val</span><span class="p">]</span>
    <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">maskvalue</span> <span class="o">&gt;&gt;</span> <span class="n">SHIFT_OVERFLOW</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span>
    <span class="n">res</span><span class="p">[</span><span class="s1">&#39;over&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_errdict_rev</span><span class="p">[</span><span class="n">val</span><span class="p">]</span>
    <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">maskvalue</span> <span class="o">&gt;&gt;</span> <span class="n">SHIFT_UNDERFLOW</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span>
    <span class="n">res</span><span class="p">[</span><span class="s1">&#39;under&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_errdict_rev</span><span class="p">[</span><span class="n">val</span><span class="p">]</span>
    <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">maskvalue</span> <span class="o">&gt;&gt;</span> <span class="n">SHIFT_INVALID</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span>
    <span class="n">res</span><span class="p">[</span><span class="s1">&#39;invalid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_errdict_rev</span><span class="p">[</span><span class="n">val</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="k">def</span> <span class="nf">setbufsize</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set the size of the buffer used in ufuncs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    size : int</span>
<span class="sd">        Size of buffer.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="n">e6</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Buffer size, </span><span class="si">%s</span><span class="s2">, is too big.&quot;</span> <span class="o">%</span> <span class="n">size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Buffer size, </span><span class="si">%s</span><span class="s2">, is too small.&quot;</span> <span class="o">%</span> <span class="n">size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">size</span> <span class="o">%</span> <span class="mi">16</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Buffer size, </span><span class="si">%s</span><span class="s2">, is not a multiple of 16.&quot;</span> <span class="o">%</span> <span class="n">size</span><span class="p">)</span>

    <span class="n">pyvals</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">geterrobj</span><span class="p">()</span>
    <span class="n">old</span> <span class="o">=</span> <span class="n">getbufsize</span><span class="p">()</span>
    <span class="n">pyvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>
    <span class="n">umath</span><span class="o">.</span><span class="n">seterrobj</span><span class="p">(</span><span class="n">pyvals</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">old</span>

<span class="k">def</span> <span class="nf">getbufsize</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the size of the buffer used in ufuncs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    getbufsize : int</span>
<span class="sd">        Size of ufunc buffer in bytes.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">umath</span><span class="o">.</span><span class="n">geterrobj</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">seterrcall</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set the floating-point error callback function or log object.</span>

<span class="sd">    There are two ways to capture floating-point error messages.  The first</span>
<span class="sd">    is to set the error-handler to &#39;call&#39;, using `seterr`.  Then, set</span>
<span class="sd">    the function to call using this function.</span>

<span class="sd">    The second is to set the error-handler to &#39;log&#39;, using `seterr`.</span>
<span class="sd">    Floating-point errors then trigger a call to the &#39;write&#39; method of</span>
<span class="sd">    the provided object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : callable f(err, flag) or object with write method</span>
<span class="sd">        Function to call upon floating-point errors (&#39;call&#39;-mode) or</span>
<span class="sd">        object whose &#39;write&#39; method is used to log such message (&#39;log&#39;-mode).</span>

<span class="sd">        The call function takes two arguments. The first is a string describing the</span>
<span class="sd">        type of error (such as &quot;divide by zero&quot;, &quot;overflow&quot;, &quot;underflow&quot;, or &quot;invalid value&quot;),</span>
<span class="sd">        and the second is the status flag.  The flag is a byte, whose four</span>
<span class="sd">        least-significant bits indicate the type of error, one of &quot;divide&quot;, &quot;over&quot;,</span>
<span class="sd">        &quot;under&quot;, &quot;invalid&quot;::</span>

<span class="sd">          [0 0 0 0 divide over under invalid]</span>

<span class="sd">        In other words, ``flags = divide + 2*over + 4*under + 8*invalid``.</span>

<span class="sd">        If an object is provided, its write method should take one argument,</span>
<span class="sd">        a string.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    h : callable, log instance or None</span>
<span class="sd">        The old error handler.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    seterr, geterr, geterrcall</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Callback upon error:</span>

<span class="sd">    &gt;&gt;&gt; def err_handler(type, flag):</span>
<span class="sd">    ...     print(&quot;Floating point error (%s), with flag %s&quot; % (type, flag))</span>
<span class="sd">    ...</span>

<span class="sd">    &gt;&gt;&gt; saved_handler = np.seterrcall(err_handler)</span>
<span class="sd">    &gt;&gt;&gt; save_err = np.seterr(all=&#39;call&#39;)</span>

<span class="sd">    &gt;&gt;&gt; np.array([1, 2, 3]) / 0.0</span>
<span class="sd">    Floating point error (divide by zero), with flag 1</span>
<span class="sd">    array([ Inf,  Inf,  Inf])</span>

<span class="sd">    &gt;&gt;&gt; np.seterrcall(saved_handler)</span>
<span class="sd">    &lt;function err_handler at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; np.seterr(**save_err)</span>
<span class="sd">    {&#39;over&#39;: &#39;call&#39;, &#39;divide&#39;: &#39;call&#39;, &#39;invalid&#39;: &#39;call&#39;, &#39;under&#39;: &#39;call&#39;}</span>

<span class="sd">    Log error message:</span>

<span class="sd">    &gt;&gt;&gt; class Log(object):</span>
<span class="sd">    ...     def write(self, msg):</span>
<span class="sd">    ...         print(&quot;LOG: %s&quot; % msg)</span>
<span class="sd">    ...</span>

<span class="sd">    &gt;&gt;&gt; log = Log()</span>
<span class="sd">    &gt;&gt;&gt; saved_handler = np.seterrcall(log)</span>
<span class="sd">    &gt;&gt;&gt; save_err = np.seterr(all=&#39;log&#39;)</span>

<span class="sd">    &gt;&gt;&gt; np.array([1, 2, 3]) / 0.0</span>
<span class="sd">    LOG: Warning: divide by zero encountered in divide</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">    array([ Inf,  Inf,  Inf])</span>

<span class="sd">    &gt;&gt;&gt; np.seterrcall(saved_handler)</span>
<span class="sd">    &lt;__main__.Log object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; np.seterr(**save_err)</span>
<span class="sd">    {&#39;over&#39;: &#39;log&#39;, &#39;divide&#39;: &#39;log&#39;, &#39;invalid&#39;: &#39;log&#39;, &#39;under&#39;: &#39;log&#39;}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Callable</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;write&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">write</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Callable</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only callable can be used as callback&quot;</span><span class="p">)</span>
    <span class="n">pyvals</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">geterrobj</span><span class="p">()</span>
    <span class="n">old</span> <span class="o">=</span> <span class="n">geterrcall</span><span class="p">()</span>
    <span class="n">pyvals</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
    <span class="n">umath</span><span class="o">.</span><span class="n">seterrobj</span><span class="p">(</span><span class="n">pyvals</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">old</span>

<span class="k">def</span> <span class="nf">geterrcall</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the current callback function used on floating-point errors.</span>

<span class="sd">    When the error handling for a floating-point error (one of &quot;divide&quot;,</span>
<span class="sd">    &quot;over&quot;, &quot;under&quot;, or &quot;invalid&quot;) is set to &#39;call&#39; or &#39;log&#39;, the function</span>
<span class="sd">    that is called or the log instance that is written to is returned by</span>
<span class="sd">    `geterrcall`. This function or log instance has been set with</span>
<span class="sd">    `seterrcall`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    errobj : callable, log instance or None</span>
<span class="sd">        The current error handler. If no handler was set through `seterrcall`,</span>
<span class="sd">        ``None`` is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    seterrcall, seterr, geterr</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For complete documentation of the types of floating-point exceptions and</span>
<span class="sd">    treatment options, see `seterr`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.geterrcall()  # we did not yet set a handler, returns None</span>

<span class="sd">    &gt;&gt;&gt; oldsettings = np.seterr(all=&#39;call&#39;)</span>
<span class="sd">    &gt;&gt;&gt; def err_handler(type, flag):</span>
<span class="sd">    ...     print(&quot;Floating point error (%s), with flag %s&quot; % (type, flag))</span>
<span class="sd">    &gt;&gt;&gt; oldhandler = np.seterrcall(err_handler)</span>
<span class="sd">    &gt;&gt;&gt; np.array([1, 2, 3]) / 0.0</span>
<span class="sd">    Floating point error (divide by zero), with flag 1</span>
<span class="sd">    array([ Inf,  Inf,  Inf])</span>

<span class="sd">    &gt;&gt;&gt; cur_handler = np.geterrcall()</span>
<span class="sd">    &gt;&gt;&gt; cur_handler is err_handler</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">umath</span><span class="o">.</span><span class="n">geterrobj</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">_unspecified</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">_Unspecified</span> <span class="o">=</span> <span class="n">_unspecified</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">errstate</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    errstate(**kwargs)</span>

<span class="sd">    Context manager for floating-point error handling.</span>

<span class="sd">    Using an instance of `errstate` as a context manager allows statements in</span>
<span class="sd">    that context to execute with a known error handling behavior. Upon entering</span>
<span class="sd">    the context the error handling is set with `seterr` and `seterrcall`, and</span>
<span class="sd">    upon exiting it is reset to what it was before.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    kwargs : {divide, over, under, invalid}</span>
<span class="sd">        Keyword arguments. The valid keywords are the possible floating-point</span>
<span class="sd">        exceptions. Each keyword should have a string value that defines the</span>
<span class="sd">        treatment for the particular error. Possible values are</span>
<span class="sd">        {&#39;ignore&#39;, &#39;warn&#39;, &#39;raise&#39;, &#39;call&#39;, &#39;print&#39;, &#39;log&#39;}.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    seterr, geterr, seterrcall, geterrcall</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The ``with`` statement was introduced in Python 2.5, and can only be used</span>
<span class="sd">    there by importing it: ``from __future__ import with_statement``. In</span>
<span class="sd">    earlier Python versions the ``with`` statement is not available.</span>

<span class="sd">    For complete documentation of the types of floating-point exceptions and</span>
<span class="sd">    treatment options, see `seterr`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from __future__ import with_statement  # use &#39;with&#39; in Python 2.5</span>
<span class="sd">    &gt;&gt;&gt; olderr = np.seterr(all=&#39;ignore&#39;)  # Set error handling to known state.</span>

<span class="sd">    &gt;&gt;&gt; np.arange(3) / 0.</span>
<span class="sd">    array([ NaN,  Inf,  Inf])</span>
<span class="sd">    &gt;&gt;&gt; with np.errstate(divide=&#39;warn&#39;):</span>
<span class="sd">    ...     np.arange(3) / 0.</span>
<span class="sd">    ...</span>
<span class="sd">    __main__:2: RuntimeWarning: divide by zero encountered in divide</span>
<span class="sd">    array([ NaN,  Inf,  Inf])</span>

<span class="sd">    &gt;&gt;&gt; np.sqrt(-1)</span>
<span class="sd">    nan</span>
<span class="sd">    &gt;&gt;&gt; with np.errstate(invalid=&#39;raise&#39;):</span>
<span class="sd">    ...     np.sqrt(-1)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;</span>
<span class="sd">    FloatingPointError: invalid value encountered in sqrt</span>

<span class="sd">    Outside the context the error handling behavior has not changed:</span>

<span class="sd">    &gt;&gt;&gt; np.geterr()</span>
<span class="sd">    {&#39;over&#39;: &#39;warn&#39;, &#39;divide&#39;: &#39;warn&#39;, &#39;invalid&#39;: &#39;warn&#39;,</span>
<span class="sd">    &#39;under&#39;: &#39;ignore&#39;}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Note that we don&#39;t want to run the above doctests because they will fail</span>
    <span class="c1"># without a from __future__ import with_statement</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">call</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;call&#39;</span><span class="p">,</span> <span class="n">_Unspecified</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">oldstate</span> <span class="o">=</span> <span class="n">seterr</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">call</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_Unspecified</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">oldcall</span> <span class="o">=</span> <span class="n">seterrcall</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">call</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">exc_info</span><span class="p">):</span>
        <span class="n">seterr</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">oldstate</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">call</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_Unspecified</span><span class="p">:</span>
            <span class="n">seterrcall</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">oldcall</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_setdef</span><span class="p">():</span>
    <span class="n">defval</span> <span class="o">=</span> <span class="p">[</span><span class="n">UFUNC_BUFSIZE_DEFAULT</span><span class="p">,</span> <span class="n">ERR_DEFAULT</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">umath</span><span class="o">.</span><span class="n">seterrobj</span><span class="p">(</span><span class="n">defval</span><span class="p">)</span>

<span class="c1"># set the default values</span>
<span class="n">_setdef</span><span class="p">()</span>

<span class="n">Inf</span> <span class="o">=</span> <span class="n">inf</span> <span class="o">=</span> <span class="n">infty</span> <span class="o">=</span> <span class="n">Infinity</span> <span class="o">=</span> <span class="n">PINF</span>
<span class="n">nan</span> <span class="o">=</span> <span class="n">NaN</span> <span class="o">=</span> <span class="n">NAN</span>
<span class="n">False_</span> <span class="o">=</span> <span class="n">bool_</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">True_</span> <span class="o">=</span> <span class="n">bool_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">.umath</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.numerictypes</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">fromnumeric</span>
<span class="kn">from</span> <span class="nn">.fromnumeric</span> <span class="k">import</span> <span class="o">*</span>
<span class="n">extend_all</span><span class="p">(</span><span class="n">fromnumeric</span><span class="p">)</span>
<span class="n">extend_all</span><span class="p">(</span><span class="n">umath</span><span class="p">)</span>
<span class="n">extend_all</span><span class="p">(</span><span class="n">numerictypes</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Eugene Scherba.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.0.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>